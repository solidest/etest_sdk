/**
 * LR parser generated by the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 *   npm install -g syntax-cli
 *
 *   syntax-cli --help
 *
 * To regenerate run:
 *
 *   syntax-cli \
 *     --grammar ~/path-to-grammar-file \
 *     --mode <parsing-mode> \
 *     --output ~/path-to-output-parser-file.js
 */

'use strict';

/**
 * Matched token text.
 */
let yytext;

/**
 * Length of the matched token text.
 */
let yyleng;

/**
 * Storage object.
 */
let yy = {};

/**
 * Result of semantic action.
 */
let __;

/**
 * Result location object.
 */
let __loc;

function yyloc(start, end) {
  if (!yy.options.captureLocations) {
    return null;
  }

  // Epsilon doesn't produce location.
  if (!start || !end) {
    return start || end;
  }

  return {
    startOffset: start.startOffset,
    endOffset: end.endOffset,
    startLine: start.startLine,
    endLine: end.endLine,
    startColumn: start.startColumn,
    endColumn: end.endColumn,
  };
}

const EOF = '$';

/**
 * List of productions (generated by Syntax tool).
 */
const productions = [[-1,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1 }],
[0,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1 }],
[1,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[1,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[1,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = {kind: 'not', exp: _2}; }],
[1,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = {kind: 'uminus', exp: _2}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'not_eq', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'eq_eq', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'gt_eq', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'lt_eq', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'gt', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'lt', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'add', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'subtract', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'multiply', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'divide', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'and', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = {kind: 'or', left: _1, right: _3}; }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = _2; }],
[1,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = newKindList('array', null); }],
[1,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = _2; }],
[1,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[2,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = { kind: _1 }; }],
[2,4,(_1,_2,_3,_4,_1loc,_2loc,_3loc,_4loc) => { __loc = yyloc(_1loc, _4loc);__ = {kind: _1, params: _3}; }],
[3,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newList(_1); }],
[3,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = joinList(_1, _3); }],
[3,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = _1; }],
[4,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newKindList('array', _1); }],
[4,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = joinKindList(_1, _3); }],
[4,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = _1; }],
[5,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'number', value: eval(yytext)}; }],
[5,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'number', value: eval(yytext)}; }],
[5,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[5,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = _1; }],
[5,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'bool', value: true}; }],
[5,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'bool', value: false}; }],
[6,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newKindList('pid', _1); }],
[6,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = joinKindList(_1, _3); }],
[7,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'string', value: eval(yytext)}; }],
[7,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'string', value: eval(yytext)}; }],
[7,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = {kind: 'strhex',  value: yytext.replace(/%/g, '')}; }],
[8,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = newList(null); }],
[8,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = _2; }],
[9,1,(_1,_1loc) => { __loc = yyloc(_1loc, _1loc);__ = newList(_1); }],
[9,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = joinList(_1, _3); }],
[9,2,(_1,_2,_1loc,_2loc) => { __loc = yyloc(_1loc, _2loc);__ = _1; }],
[10,3,(_1,_2,_3,_1loc,_2loc,_3loc) => { __loc = yyloc(_1loc, _3loc);__ = newProp(_1, _3, _1loc, _3loc); }]];

/**
 * Encoded tokens map.
 */
const tokens = {"NOT":"11","-":"12","NOT_EQ":"13","EQ_EQ":"14","GT_EQ":"15","LT_EQ":"16",">":"17","<":"18","+":"19","*":"20","/":"21","AND":"22","OR":"23","(":"24",")":"25","[":"26","]":"27","ID":"28",",":"29","NUMBER":"30","NUMBER_HEX":"31","TRUE":"32","FALSE":"33","DOT":"34","STRING_TRIPLE":"35","STRING_SINGLE":"36","STRING_HEX":"37","{":"38","}":"39",":":"40","$":"41"};

/**
 * Parsing table (generated by Syntax tool).
 */
const table = [{"0":1,"1":2,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"41":"acc"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"s31","23":"s32","41":"r1"},{"12":"r2","13":"r2","14":"r2","15":"r2","16":"r2","17":"r2","18":"r2","19":"r2","20":"r2","21":"r2","22":"r2","23":"r2","25":"r2","27":"r2","29":"r2","39":"r2","41":"r2"},{"12":"r3","13":"r3","14":"r3","15":"r3","16":"r3","17":"r3","18":"r3","19":"r3","20":"r3","21":"r3","22":"r3","23":"r3","25":"r3","27":"r3","29":"r3","39":"r3","41":"r3"},{"1":45,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":46,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":47,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":51,"2":9,"4":50,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","27":"s49","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"12":"r21","13":"r21","14":"r21","15":"r21","16":"r21","17":"r21","18":"r21","19":"r21","20":"r21","21":"r21","22":"r21","23":"r21","25":"r21","27":"r21","29":"r21","39":"r21","41":"r21"},{"12":"r30","13":"r30","14":"r30","15":"r30","16":"r30","17":"r30","18":"r30","19":"r30","20":"r30","21":"r30","22":"r30","23":"r30","25":"r30","27":"r30","29":"r30","39":"r30","41":"r30"},{"12":"r31","13":"r31","14":"r31","15":"r31","16":"r31","17":"r31","18":"r31","19":"r31","20":"r31","21":"r31","22":"r31","23":"r31","25":"r31","27":"r31","29":"r31","39":"r31","41":"r31"},{"12":"r32","13":"r32","14":"r32","15":"r32","16":"r32","17":"r32","18":"r32","19":"r32","20":"r32","21":"r32","22":"r32","23":"r32","25":"r32","27":"r32","29":"r32","39":"r32","41":"r32"},{"12":"r33","13":"r33","14":"r33","15":"r33","16":"r33","17":"r33","18":"r33","19":"r33","20":"r33","21":"r33","22":"r33","23":"r33","25":"r33","27":"r33","29":"r33","34":"s55","39":"r33","41":"r33"},{"12":"r34","13":"r34","14":"r34","15":"r34","16":"r34","17":"r34","18":"r34","19":"r34","20":"r34","21":"r34","22":"r34","23":"r34","25":"r34","27":"r34","29":"r34","39":"r34","41":"r34"},{"12":"r35","13":"r35","14":"r35","15":"r35","16":"r35","17":"r35","18":"r35","19":"r35","20":"r35","21":"r35","22":"r35","23":"r35","25":"r35","27":"r35","29":"r35","39":"r35","41":"r35"},{"12":"r38","13":"r38","14":"r38","15":"r38","16":"r38","17":"r38","18":"r38","19":"r38","20":"r38","21":"r38","22":"r38","23":"r38","25":"r38","27":"r38","29":"r38","39":"r38","41":"r38"},{"12":"r39","13":"r39","14":"r39","15":"r39","16":"r39","17":"r39","18":"r39","19":"r39","20":"r39","21":"r39","22":"r39","23":"r39","25":"r39","27":"r39","29":"r39","39":"r39","41":"r39"},{"12":"r40","13":"r40","14":"r40","15":"r40","16":"r40","17":"r40","18":"r40","19":"r40","20":"r40","21":"r40","22":"r40","23":"r40","25":"r40","27":"r40","29":"r40","39":"r40","41":"r40"},{"12":"r36","13":"r36","14":"r36","15":"r36","16":"r36","17":"r36","18":"r36","19":"r36","20":"r36","21":"r36","22":"r36","23":"r36","24":"s57","25":"r36","27":"r36","29":"r36","34":"r36","39":"r36","41":"r36"},{"9":65,"10":66,"28":"s67","39":"s64"},{"1":33,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":34,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":35,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":36,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":37,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":38,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":39,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":40,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":41,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":42,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":43,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"1":44,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"12":"s28","13":"r6","14":"r6","15":"r6","16":"r6","17":"r6","18":"r6","19":"s27","20":"s29","21":"s30","22":"r6","23":"r6","25":"r6","27":"r6","29":"r6","39":"r6","41":"r6"},{"12":"s28","13":"r7","14":"r7","15":"r7","16":"r7","17":"r7","18":"r7","19":"s27","20":"s29","21":"s30","22":"r7","23":"r7","25":"r7","27":"r7","29":"r7","39":"r7","41":"r7"},{"12":"s28","13":"r8","14":"r8","15":"r8","16":"r8","17":"r8","18":"r8","19":"s27","20":"s29","21":"s30","22":"r8","23":"r8","25":"r8","27":"r8","29":"r8","39":"r8","41":"r8"},{"12":"s28","13":"r9","14":"r9","15":"r9","16":"r9","17":"r9","18":"r9","19":"s27","20":"s29","21":"s30","22":"r9","23":"r9","25":"r9","27":"r9","29":"r9","39":"r9","41":"r9"},{"12":"s28","13":"r10","14":"r10","15":"r10","16":"r10","17":"r10","18":"r10","19":"s27","20":"s29","21":"s30","22":"r10","23":"r10","25":"r10","27":"r10","29":"r10","39":"r10","41":"r10"},{"12":"s28","13":"r11","14":"r11","15":"r11","16":"r11","17":"r11","18":"r11","19":"s27","20":"s29","21":"s30","22":"r11","23":"r11","25":"r11","27":"r11","29":"r11","39":"r11","41":"r11"},{"12":"r12","13":"r12","14":"r12","15":"r12","16":"r12","17":"r12","18":"r12","19":"r12","20":"s29","21":"s30","22":"r12","23":"r12","25":"r12","27":"r12","29":"r12","39":"r12","41":"r12"},{"12":"r13","13":"r13","14":"r13","15":"r13","16":"r13","17":"r13","18":"r13","19":"r13","20":"s29","21":"s30","22":"r13","23":"r13","25":"r13","27":"r13","29":"r13","39":"r13","41":"r13"},{"12":"r14","13":"r14","14":"r14","15":"r14","16":"r14","17":"r14","18":"r14","19":"r14","20":"r14","21":"r14","22":"r14","23":"r14","25":"r14","27":"r14","29":"r14","39":"r14","41":"r14"},{"12":"r15","13":"r15","14":"r15","15":"r15","16":"r15","17":"r15","18":"r15","19":"r15","20":"r15","21":"r15","22":"r15","23":"r15","25":"r15","27":"r15","29":"r15","39":"r15","41":"r15"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"r16","23":"r16","25":"r16","27":"r16","29":"r16","39":"r16","41":"r16"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"r17","23":"r17","25":"r17","27":"r17","29":"r17","39":"r17","41":"r17"},{"12":"r4","13":"r4","14":"r4","15":"r4","16":"r4","17":"r4","18":"r4","19":"r4","20":"r4","21":"r4","22":"r4","23":"r4","25":"r4","27":"r4","29":"r4","39":"r4","41":"r4"},{"12":"r5","13":"r5","14":"r5","15":"r5","16":"r5","17":"r5","18":"r5","19":"r5","20":"r5","21":"r5","22":"r5","23":"r5","25":"r5","27":"r5","29":"r5","39":"r5","41":"r5"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"s31","23":"s32","25":"s48"},{"12":"r18","13":"r18","14":"r18","15":"r18","16":"r18","17":"r18","18":"r18","19":"r18","20":"r18","21":"r18","22":"r18","23":"r18","25":"r18","27":"r18","29":"r18","39":"r18","41":"r18"},{"12":"r19","13":"r19","14":"r19","15":"r19","16":"r19","17":"r19","18":"r19","19":"r19","20":"r19","21":"r19","22":"r19","23":"r19","25":"r19","27":"r19","29":"r19","39":"r19","41":"r19"},{"27":"s52","29":"s53"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"s31","23":"s32","27":"r27","29":"r27"},{"12":"r20","13":"r20","14":"r20","15":"r20","16":"r20","17":"r20","18":"r20","19":"r20","20":"r20","21":"r20","22":"r20","23":"r20","25":"r20","27":"r20","29":"r20","39":"r20","41":"r20"},{"1":54,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","27":"r29","28":"s19","29":"r29","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"s31","23":"s32","27":"r28","29":"r28"},{"28":"s56"},{"12":"r37","13":"r37","14":"r37","15":"r37","16":"r37","17":"r37","18":"r37","19":"r37","20":"r37","21":"r37","22":"r37","23":"r37","25":"r37","27":"r37","29":"r37","34":"r37","39":"r37","41":"r37"},{"1":60,"2":9,"3":59,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","25":"s58","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"12":"r22","13":"r22","14":"r22","15":"r22","16":"r22","17":"r22","18":"r22","19":"r22","20":"r22","21":"r22","22":"r22","23":"r22","25":"r22","27":"r22","29":"r22","39":"r22","41":"r22"},{"25":"s61","29":"s62"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"s31","23":"s32","25":"r24","29":"r24"},{"12":"r23","13":"r23","14":"r23","15":"r23","16":"r23","17":"r23","18":"r23","19":"r23","20":"r23","21":"r23","22":"r23","23":"r23","25":"r23","27":"r23","29":"r23","39":"r23","41":"r23"},{"1":63,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","25":"r26","26":"s8","28":"s19","29":"r26","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"s31","23":"s32","25":"r25","29":"r25"},{"12":"r41","13":"r41","14":"r41","15":"r41","16":"r41","17":"r41","18":"r41","19":"r41","20":"r41","21":"r41","22":"r41","23":"r41","25":"r41","27":"r41","29":"r41","39":"r41","41":"r41"},{"29":"s69","39":"s68"},{"29":"r43","39":"r43"},{"40":"s71"},{"12":"r42","13":"r42","14":"r42","15":"r42","16":"r42","17":"r42","18":"r42","19":"r42","20":"r42","21":"r42","22":"r42","23":"r42","25":"r42","27":"r42","29":"r42","39":"r42","41":"r42"},{"10":70,"28":"s67","29":"r45","39":"r45"},{"29":"r44","39":"r44"},{"1":72,"2":9,"5":3,"6":13,"7":12,"8":4,"11":"s5","12":"s6","24":"s7","26":"s8","28":"s19","30":"s10","31":"s11","32":"s14","33":"s15","35":"s16","36":"s17","37":"s18","38":"s20"},{"12":"s28","13":"s21","14":"s22","15":"s23","16":"s24","17":"s25","18":"s26","19":"s27","20":"s29","21":"s30","22":"s31","23":"s32","29":"r46","39":"r46"}];

/**
 * Parsing stack.
 */
const stack = [];

/**
 * Tokenizer instance.
 */
let tokenizer;
/**
 * Generic tokenizer used by the parser in the Syntax tool.
 *
 * https://www.npmjs.com/package/syntax-cli
 *
 * See `--custom-tokinzer` to skip this generation, and use a custom one.
 */

const lexRules = [[/^\/\*[^*]*\*+([^\/][^*]*\*+)*\//, function() { /*return 'COMMENT_BLOCK'*/ }],
[/^\/\/[^\r\n]*/, function() { /*return 'COMMENT_LINE'*/ }],
[/^\"([^\\\n"]|\\.)*\"/, function() { return 'STRING_TRIPLE' }],
[/^'([^\\\n']|\\.)*'/, function() { return 'STRING_SINGLE' }],
[/^%[0-9A-Fa-f\s]*%/, function() { return 'STRING_HEX' }],
[/^\s+/, function() { /* return 'WHITESPACE' */ }],
[/^\n/, function() { /* return 'NEWLINE' */ }],
[/^\bbitlr\b/, function() { return 'BITLR'  }],
[/^\bbitrl\b/, function() { return 'BITRL'  }],
[/^\bprotocol\b/, function() { if(this.getCurrentState()!=='INITIAL') this.popState(); this.pushState('protocol'); return 'PROTOCOL'; }],
[/^\bsegments\b/, function() { return 'SEGMENTS' }],
[/^\bsegment\b/, function() { return 'SEGMENT' }],
[/^\boneof\b/, function() { return 'ONEOF' }],
[/^\bwhen\b/, function() { return 'WHEN' }],
[/^\bas\b/, function() { return 'AS' }],
[/^\bdevice\b/, function() { if(this.getCurrentState()!=='INITIAL') this.popState(); this.pushState('device'); return 'DEVICE'; }],
[/^\b(udp|tcp_server|tcp_client|serial_ttl|serial_232|serial_422|serial_485|serial_usb|can|di|do|ai|ao)\b/, function() { return 'INTFTYPE' }],
[/^\btopology\b/, function() { if(this.getCurrentState()!=='INITIAL') this.popState(); this.pushState('topology'); return 'TOPOLOGY'; }],
[/^\blinking\b/, function() { return 'LINKING' }],
[/^\bmapping\b/, function() { return 'MAPPING' }],
[/^\bbinding\b/, function() { return 'BINDING' }],
[/^\bsimu\b/, function() { return 'SIMU' }],
[/^\buut\b/, function() { return 'UUT' }],
[/^\betest\b/, function() { return 'ETEST' }],
[/^true/, function() { return 'TRUE' }],
[/^false/, function() { return 'FALSE' }],
[/^and/, function() { return 'AND' }],
[/^or/, function() { return 'OR' }],
[/^not/, function() { return 'NOT' }],
[/^0[xX][0-9a-fA-F]+/, function() { return 'NUMBER_HEX' }],
[/^[0-9]+(?:\.[0-9]+)?/, function() { return 'NUMBER' }],
[/^[a-zA-Z_$][a-zA-Z0-9_]*/, function() { return 'ID' }],
[/^~=/, function() { return 'NOT_EQ' }],
[/^==/, function() { return 'EQ_EQ' }],
[/^>=/, function() { return 'GT_EQ' }],
[/^<=/, function() { return 'LT_EQ' }],
[/^{/, function() { return '{' }],
[/^}/, function() { return '}' }],
[/^]/, function() { return ']' }],
[/^\[/, function() { return '[' }],
[/^,/, function() { return ',' }],
[/^\:/, function() { return ':' }],
[/^\./, function() { return 'DOT' }],
[/^\+/, function() { return '+' }],
[/^-/, function() { return '-' }],
[/^\*/, function() { return '*' }],
[/^\//, function() { return '/' }],
[/^\(/, function() { return '(' }],
[/^\)/, function() { return ')' }],
[/^>/, function() { return '>' }],
[/^</, function() { return '<' }]];
const lexRulesByConditions = {"INITIAL":[0,1,2,3,4,5,6,7,8,9,15,17,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],"protocol":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],"device":[0,1,2,3,4,5,6,7,8,9,15,16,17,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50],"topology":[0,1,2,3,4,5,6,7,8,9,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50]};

const EOF_TOKEN = {
  type: EOF,
  value: '',
};

tokenizer = {
  initString(string) {
    this._string = string;
    this._cursor = 0;

    this._states = ['INITIAL'];
    this._tokensQueue = [];

    this._currentLine = 1;
    this._currentColumn = 0;
    this._currentLineBeginOffset = 0;

    /**
     * Matched token location data.
     */
    this._tokenStartOffset = 0;
    this._tokenEndOffset = 0;
    this._tokenStartLine = 1;
    this._tokenEndLine = 1;
    this._tokenStartColumn = 0;
    this._tokenEndColumn = 0;

    return this;
  },

  /**
   * Returns tokenizer states.
   */
  getStates() {
    return this._states;
  },

  getCurrentState() {
    return this._states[this._states.length - 1];
  },

  pushState(state) {
    this._states.push(state);
  },

  begin(state) {
    this.pushState(state);
  },

  popState() {
    if (this._states.length > 1) {
      return this._states.pop();
    }
    return this._states[0];
  },

  getNextToken() {
    // Something was queued, return it.
    if (this._tokensQueue.length > 0) {
      return this.onToken(this._toToken(this._tokensQueue.shift()));
    }

    if (!this.hasMoreTokens()) {
      return this.onToken(EOF_TOKEN);
    }

    let string = this._string.slice(this._cursor);
    let lexRulesForState = lexRulesByConditions[this.getCurrentState()];

    for (let i = 0; i < lexRulesForState.length; i++) {
      let lexRuleIndex = lexRulesForState[i];
      let lexRule = lexRules[lexRuleIndex];

      let matched = this._match(string, lexRule[0]);

      // Manual handling of EOF token (the end of string). Return it
      // as `EOF` symbol.
      if (string === '' && matched === '') {
        this._cursor++;
      }

      if (matched !== null) {
        yytext = matched;
        yyleng = yytext.length;
        let token = lexRule[1].call(this);

        if (!token) {
          return this.getNextToken();
        }

        // If multiple tokens are returned, save them to return
        // on next `getNextToken` call.

        if (Array.isArray(token)) {
          const tokensToQueue = token.slice(1);
          token = token[0];
          if (tokensToQueue.length > 0) {
            this._tokensQueue.unshift(...tokensToQueue);
          }
        }

        return this.onToken(this._toToken(token, yytext));
      }
    }

    if (this.isEOF()) {
      this._cursor++;
      return EOF_TOKEN;
    }

    this.throwUnexpectedToken(
      string[0],
      this._currentLine,
      this._currentColumn
    );
  },

  /**
   * Throws default "Unexpected token" exception, showing the actual
   * line from the source, pointing with the ^ marker to the bad token.
   * In addition, shows `line:column` location.
   */
  throwUnexpectedToken(symbol, line, column) {
    const lineSource = this._string.split('\n')[line - 1];
    let lineData = '';

    if (lineSource) {
      const pad = ' '.repeat(column);
      lineData = '\n\n' + lineSource + '\n' + pad + '^\n';
    }

    throw new SyntaxError(
      `${lineData}Unexpected token: "${symbol}" ` +
      `at ${line}:${column}.`
    );
  },

  getCursor() {
    return this._cursor;
  },

  getCurrentLine() {
    return this._currentLine;
  },

  getCurrentColumn() {
    return this._currentColumn;
  },

  _captureLocation(matched) {
    const nlRe = /\n/g;

    // Absolute offsets.
    this._tokenStartOffset = this._cursor;

    // Line-based locations, start.
    this._tokenStartLine = this._currentLine;
    this._tokenStartColumn =
      this._tokenStartOffset - this._currentLineBeginOffset;

    // Extract `\n` in the matched token.
    let nlMatch;
    while ((nlMatch = nlRe.exec(matched)) !== null) {
      this._currentLine++;
      this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
    }

    this._tokenEndOffset = this._cursor + matched.length;

    // Line-based locations, end.
    this._tokenEndLine = this._currentLine;
    this._tokenEndColumn = this._currentColumn =
      (this._tokenEndOffset - this._currentLineBeginOffset);
  },

  _toToken(tokenType, yytext = '') {
    return {
      // Basic data.
      type: tokenType,
      value: yytext,

      // Location data.
      startOffset: this._tokenStartOffset,
      endOffset: this._tokenEndOffset,
      startLine: this._tokenStartLine,
      endLine: this._tokenEndLine,
      startColumn: this._tokenStartColumn,
      endColumn: this._tokenEndColumn,
    };
  },

  isEOF() {
    return this._cursor === this._string.length;
  },

  hasMoreTokens() {
    return this._cursor <= this._string.length;
  },

  _match(string, regexp) {
    let matched = string.match(regexp);
    if (matched) {
      // Handle `\n` in the matched token to track line numbers.
      this._captureLocation(matched[0]);
      this._cursor += matched[0].length;
      return matched[0];
    }
    return null;
  },

  /**
   * Allows analyzing, and transforming token. Default implementation
   * just passes the token through.
   */
  onToken(token) {
    return token;
  },
};

/**
 * Expose tokenizer so it can be accessed in semantic actions.
 */
yy.lexer = tokenizer;
yy.tokenizer = tokenizer;

/**
 * Global parsing options. Some options can be shadowed per
 * each `parse` call, if the optations are passed.
 *
 * Initalized to the `captureLocations` which is passed
 * from the generator. Other options can be added at runtime.
 */
yy.options = {
  captureLocations: true,
};

/**
 * Parsing module.
 */
const yyparse = {
  /**
   * Sets global parsing options.
   */
  setOptions(options) {
    yy.options = options;
    return this;
  },

  /**
   * Returns parsing options.
   */
  getOptions() {
    return yy.options;
  },

  /**
   * Parses a string.
   */
  parse(string, parseOptions) {
    if (!tokenizer) {
      throw new Error(`Tokenizer instance wasn't specified.`);
    }

    tokenizer.initString(string);

    /**
     * If parse options are passed, override global parse options for
     * this call, and later restore global options.
     */
    let globalOptions = yy.options;
    if (parseOptions) {
      yy.options = Object.assign({}, yy.options, parseOptions);
    }

    /**
     * Allow callers to do setup work based on the
     * parsing string, and passed options.
     */
    yyparse.onParseBegin(string, tokenizer, yy.options);

    stack.length = 0;
    stack.push(0);

    let token = tokenizer.getNextToken();
    let shiftedToken = null;

    do {
      if (!token) {
        // Restore options.
        yy.options = globalOptions;
        unexpectedEndOfInput();
      }

      let state = stack[stack.length - 1];
      let column = tokens[token.type];

      if (!table[state].hasOwnProperty(column)) {
        yy.options = globalOptions;
        unexpectedToken(token);
      }

      let entry = table[state][column];

      // Shift action.
      if (entry[0] === 's') {
        let loc = null;

        if (yy.options.captureLocations) {
          loc = {
            startOffset: token.startOffset,
            endOffset: token.endOffset,
            startLine: token.startLine,
            endLine: token.endLine,
            startColumn: token.startColumn,
            endColumn: token.endColumn,
          };
        }

        shiftedToken = this.onShift(token);

        stack.push(
          {symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc},
          Number(entry.slice(1))
        );

        token = tokenizer.getNextToken();
      }

      // Reduce action.
      else if (entry[0] === 'r') {
        let productionNumber = entry.slice(1);
        let production = productions[productionNumber];
        let hasSemanticAction = typeof production[2] === 'function';
        let semanticValueArgs = hasSemanticAction ? [] : null;

        const locationArgs = (
          hasSemanticAction && yy.options.captureLocations
            ? []
            : null
        );

        if (production[1] !== 0) {
          let rhsLength = production[1];
          while (rhsLength-- > 0) {
            stack.pop();
            let stackEntry = stack.pop();

            if (hasSemanticAction) {
              semanticValueArgs.unshift(stackEntry.semanticValue);

              if (locationArgs) {
                locationArgs.unshift(stackEntry.loc);
              }
            }
          }
        }

        const reduceStackEntry = {symbol: production[0]};

        if (hasSemanticAction) {
          yytext = shiftedToken ? shiftedToken.value : null;
          yyleng = shiftedToken ? shiftedToken.value.length : null;

          const semanticActionArgs = (
            locationArgs !== null
              ? semanticValueArgs.concat(locationArgs)
              : semanticValueArgs
          );

          production[2](...semanticActionArgs);

          reduceStackEntry.semanticValue = __;

          if (locationArgs) {
            reduceStackEntry.loc = __loc;
          }
        }

        const nextState = stack[stack.length - 1];
        const symbolToReduceWith = production[0];

        stack.push(
          reduceStackEntry,
          table[nextState][symbolToReduceWith]
        );
      }

      // Accept.
      else if (entry === 'acc') {
        stack.pop();
        let parsed = stack.pop();

        if (stack.length !== 1 ||
            stack[0] !== 0 ||
            tokenizer.hasMoreTokens()) {
          // Restore options.
          yy.options = globalOptions;
          unexpectedToken(token);
        }

        if (parsed.hasOwnProperty('semanticValue')) {
          yy.options = globalOptions;
          yyparse.onParseEnd(parsed.semanticValue);
          return parsed.semanticValue;
        }

        yyparse.onParseEnd();

        // Restore options.
        yy.options = globalOptions;
        return true;
      }

    } while (tokenizer.hasMoreTokens() || stack.length > 1);
  },

  setTokenizer(customTokenizer) {
    tokenizer = customTokenizer;
    return yyparse;
  },

  getTokenizer() {
    return tokenizer;
  },

  onParseBegin(string, tokenizer, options) {},
  onParseEnd(parsed) {},

  /**
   * Allows analyzing, and transforming shifted token. Default implementation
   * just passes the token through.
   */
  onShift(token) {
    return token;
  },
};



    function newList(item) {
      if(item) {
        return [item];
      } else {
        return [];
      }
    }

    function joinList(list, item) {
      if(list && item) {
        list.push(item);
      }
      return list;
    }

    function newKindList(kind, item) {
      if(item) {
        return {kind: kind, list: [item]};
      } else {
        return {kind: kind, list: []};
      }
    }

    function joinKindList(list, item) {
      if(list && list.list && item) {
        list.list.push(item);
      }
      return list;
    }

    function newProp(id, exp, id_loc, exp_loc) {
      return {
        kind: 'prop',
        name: id,
        value: exp,
        name_from: id_loc.startOffset,
        name_to: id_loc.endOffset,
        name_line: id_loc.startLine,
        value_from: exp_loc.startOffset,
        value_to: exp_loc.endOffset,
        value_line: exp_loc.startLine,
      }
    }

    function newOneof(branch_list) {
      return {
        kind: 'oneof',
        branch_list: branch_list
      }
    }

    function newBranch(name, exp, seglist, exp_loc) {
      return {
        kind: 'branch',
        name: name,
        exp: exp,
        seglist: seglist,
        exp_from: exp_loc.startOffset,
        exp_to: exp_loc.endOffset,
        exp_line: exp_loc.startLine,
      }
    }

    function newProtSeggroup(name, seglist, name_loc, repeated) {
      let res = {
        kind: 'seggroup',
        name: name,
        seglist: seglist,
        name_from: name_loc.startOffset,
        name_to: name_loc.endOffset,
        name_line: name_loc.startLine,
      }
      if(repeated) {
        res.repeated = repeated;
      }
      return res;
    }

    function newElement(kind, name, body_name, body, name_loc, repeated) {
      let res = {
        kind: kind,
        name: name,
        name_from: name_loc.startOffset,
        name_to: name_loc.endOffset,
        name_line: name_loc.startLine,
      }
      res[body_name] = body;
      if(repeated) {
        res.repeated = repeated;
      }
      return res;
    }




function unexpectedToken(token) {
  if (token.type === EOF) {
    unexpectedEndOfInput();
  }

  tokenizer.throwUnexpectedToken(
    token.value,
    token.startLine,
    token.startColumn
  );
}

function unexpectedEndOfInput() {
  parseError(`Unexpected end of input.`);
}

function parseError(message) {
  throw new SyntaxError(message);
}

module.exports = yyparse;
