[
    {
        "id": "xfLlnfrzCv",
        "code": "",
        "params": [
            {
                "id": "demo",
                "title": "demo",
                "vars": null,
                "option": {
                    "topology": "topo_udp"
                }
            }
        ]
    },
    {
        "id": "Te9sG_j_u5",
        "code": "\n\nfunction entry()\n    local msg = message(protocol.prot_primitive)\n    msg.seg1 = -10.99\n    msg.seg2 = -1000299.235456\n    msg.seg3 = -97\n    msg.seg4 = -97\n    msg.seg5 = -97\n    msg.seg6 = -97\n    msg.seg7 = -97\n    local buf = pack(msg)\n    -- print(string.buff2hex(buf))\n    local len = #buf\n    assert(string.sub(buf, len-3, len-3) == string.sub(buf, len-1, len-1) and string.sub(buf, len-2, len-2) == string.sub(buf, len, len))\n    local msg2 = unpack(protocol.prot_primitive, buf)\n    assert(msg2.seg3==-97 and msg2.seg4==-97 and msg2.seg5==-97 and msg2.seg6==-97 and msg2.seg7==-97)\n    log.info('t_primitive 测试通过')\n    exit()\nend",
        "params": [
            {
                "id": "t_primitive",
                "title": "t_primitive",
                "vars": null,
                "option": {
                    "topology": "topo_udp"
                }
            }
        ]
    },
    {
        "id": "tBbpj5-Kxx",
        "code": "\nlocal helper = require 'helper'\n\nlocal test = {\n\n    -- 超长报文\n    e_udp_msg_too_long = function ()\n        local len = 65508\n        local buf_a = helper.create_buffer(len)\n        send(device.udp1.conn1, buf_a, nil)\n    end,\n\n    -- 基本通信测试\n    udp_common = function()\n        local lens = { 1, 10, 100, 1024, 65507 }\n\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            send(device.udp1.conn1, buf_a)\n            local buf_b = recv(device.udp2.conn1, nil, 3000)\n            assert(buf_a == buf_b, i .. \",\" .. #buf_a .. ',' .. #buf_b)\n        end\n    end,\n\n    -- 多报文通信\n    udp_multimsg = function ()\n        local lens = { 1, 10, 100, 1024, 65507 }\n\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            send(device.udp1.conn1, buf_a)\n        end\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            local buf_b = recv(device.udp2.conn1, nil, 3000)\n            assert(buf_a == buf_b, #buf_a .. '~=' .. #buf_b)\n        end\n    end,\n\n    -- 动态目标\n    udp_target = function ()\n        local lens = { 1, 10, 100, 1024, 65507 }\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            send(device.udp1.conn2, buf_a, { to = 'udp2.conn2'})\n        end\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            local buf_b = recv(device.udp2.conn2, nil, 3000)\n            assert(buf_a == buf_b, #buf_a .. '~=' .. #buf_b)\n        end\n        local buf_c = recv(device.udp2.conn3, nil)\n        assert(buf_c == nil)\n    end,\n\n\n    -- 广播报文测试\n    udp_broadcast = function ()\n        local lens = { 1, 10, 100, 1024 }\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            send(device.udp1.conn2, buf_a, { to_port = 8000 })\n        end\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            local buf_b = recv(device.udp2.conn4, nil, 3000)\n            assert(buf_a == buf_b, #buf_a .. '~=' .. #buf_b)\n        end\n        local buf_c = recv(device.udp2.conn3, nil)\n        assert(buf_c == nil)\n    end,\n\n    -- 异步通信测试\n    udp_async = function()\n        local lens = { 1, 10, 100, 1024, 65507 }\n        local count1 = 0\n        local count2 = 0\n        local count3 = 0\n\n        async.on_recv(device.udp2.conn1, nil,\n            function (buf)\n                count1 = count1 + 1\n                local len = #buf\n                assert(buf == helper.create_buffer(len))\n            end\n        )\n\n        async.on_recv(device.udp2.conn2, nil,\n            function (buf)\n                count2 = count2 + 1\n                local len = #buf\n                assert(buf == helper.create_buffer(len))\n            end\n        )\n\n        async.on_recv(device.udp2.conn4, nil,\n            function (buf)\n                count3 = count3 + 1\n                local len = #buf\n                assert(buf == helper.create_buffer(len))\n            end\n        )\n\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            async.send(device.udp1.conn1, buf_a)\n            async.send(device.udp1.conn2, buf_a, { to = 'udp2.conn2'})\n            async.send(device.udp1.conn2, buf_a, { to_port = 8000 })\n        end\n\n        -- count2 = #lens\n\n        for i = 1, 1000 do\n            delay(10)\n            local l = #lens\n            if count1 == l and count2 == l and count3 == l then\n                break\n            end\n        end\n        async.off_recv(device.udp2.conn1)\n        async.off_recv(device.udp2.conn2)\n        async.off_recv(device.udp2.conn4)\n\n        -- print(count1, count2, count3)\n        assert(count1 == #lens)\n        assert(count2 == #lens)\n        assert(count3 == #lens)\n    end,\n\n}\n\n\nfunction entry(vars)\n\n    -- ioctl(device.udp1.conn1, \"JoinGroup\", {group = \"244.0.2.2\"})\n    -- ioctl(device.udp1.conn1, \"LeaveGroup\", {group = \"244.0.2.2\"})\n\n    local filter = \"u\"\n\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend\n",
        "params": [
            {
                "id": "t_udp",
                "title": "t_udp",
                "vars": null,
                "option": {
                    "topology": "topo_udp"
                }
            }
        ]
    },
    {
        "id": "-YdZtpj8Im",
        "code": "\nlocal helper = require 'helper'\n\nlocal function send_recv (client, server, srv_opt)\n    local lens = { 1, 10, 100, 1024, 65507, 65*1024 }\n\n    local l1 = 0\n    local l2 = 0\n    local l3 = 0\n\n    for i, len in ipairs(lens) do\n        l1 = l1 + len\n        local buf_a = helper.create_buffer(len)\n        local slen = send(device.client[client], buf_a)\n        assert(slen == len)\n\n        for i = 1, 100 do\n            local buf_b, opt = recv(device.server[server], nil, 100)\n            if not buf_b then\n                break\n            end\n            l2 = l2 + #buf_b\n            assert(not not opt[\"client_port\"])\n        end\n\n        local slen = send(device.server[server], buf_a, srv_opt)\n        assert(slen == len)\n\n        for i = 1, 100 do\n            local buf_b, opt = recv(device.client[client], nil, 100)\n            if not buf_b then\n                break\n            end\n            l3 = l3 + #buf_b\n        end\n        assert(l2 == l1 and l3 == l1, l1 .. ',' .. l2 .. ',' .. l3)\n    end\nend\n\nlocal test = {\n\n    -- 基本通信测试\n    tcp_common = function ()\n        send_recv('tcp1', 'srva')\n        send_recv('tcp4', 'srvd')\n    end,\n\n    -- 手动连接\n    tcp_conn_disconn = function ()\n        local err_fn = function (c)\n            send(device.client[c], 'aaa\\0')\n        end\n        local res = pcall(err_fn, 'tcp2')\n        assert(not res)\n\n        local opt1 = ioctl(device.client.tcp2, 'Connect', { to = 'server.srvb'})\n        local opt2 = ioctl(device.client.tcp3, 'Connect', { to = 'server.srvc'})\n        assert(opt1[\"client_ip\"] == opt2[\"client_ip\"])\n        send_recv('tcp2', 'srvb', { to = 'client.tcp2' })\n        send_recv('tcp3', 'srvc', { to = opt2.client_ip .. ':' .. opt2.client_port })\n\n        ioctl(device.client.tcp2, 'Disconnect')\n        res = pcall(err_fn, 'tcp2')\n        assert(not res)\n        ioctl(device.client.tcp2, 'Connect', { to = 'server.srvb'})\n        send_recv('tcp2', 'srvb', { to = 'client.tcp2' })\n        ioctl(device.client.tcp2, 'Disconnect')\n        res = pcall(err_fn, 'tcp2')\n        assert(not res)\n        ioctl(device.client.tcp3, 'Disconnect')\n    end,\n\n    -- 服务器上的客户端列表\n    tcp_listclient = function ()\n        delay(10)\n        local l1 = ioctl(device.server.srva, 'ListClients')\n        assert(#l1.result == 1)\n        local l2 = ioctl(device.server.srvb, 'ListClients')\n        assert(#l2.result == 0)\n        local l3 = ioctl(device.server.srvc, 'ListClients')\n        assert(#l3.result == 0)\n        local l4 = ioctl(device.server.srvd, 'ListClients')\n        assert(#l4.result == 1)\n        local l5 = ioctl(device.server.srve, 'ListClients')\n        assert(#l5.result == 1)\n        local l6 = ioctl(device.server.srvf, 'ListClients')\n        assert(#l6.result == 0)\n        local l7 = ioctl(device.server.srvg, 'ListClients')\n        assert(#l7.result == 0)\n        ioctl(device.client.tcp2, 'Connect', { to = 'server.srvb'})\n        ioctl(device.client.tcp3, 'Connect', { to = 'server.srvb'})\n        l2 = ioctl(device.server.srvb, 'ListClients')\n        assert(#l2.result == 2)\n        ioctl(device.client.tcp2, 'Disconnect')\n        delay(10)\n        l2 = ioctl(device.server.srvb, 'ListClients')\n        assert(#l2.result == 1)\n        ioctl(device.server.srvb, 'Refuse')\n        delay(10)\n        l2 = ioctl(device.server.srvb, 'ListClients')\n        assert(#l2.result == 0)\n        ioctl(device.client.tcp3, 'Disconnect')\n    end,\n\n    -- 客户端无ip或端口\n    tcp_empty_ip_port = function ()\n        send_recv('tcp4', 'srvd')\n        send_recv('tcp5', 'srve')\n        \n        local opt1 = ioctl(device.client.tcp6, 'Connect', { to = 'server.srvf'})\n        local opt2 = ioctl(device.client.tcp7, 'Connect', { to = 'server.srvg'})\n        assert(opt1[\"client_ip\"] == opt2[\"client_ip\"])\n        send_recv('tcp6', 'srvf', { to = opt1.client_ip .. ':' .. opt1.client_port })\n        send_recv('tcp7', 'srvg', { to = opt2.client_ip .. ':' .. opt2.client_port })\n        ioctl(device.client.tcp6, 'Disconnect' )\n        ioctl(device.client.tcp7, 'Disconnect' )\n    end,\n\n    -- 多报文通信\n    tcp_multimsg = function ()\n        local lens = { 1, 10, 100, 1024, 65507, 65*1024 }\n\n        local l1 = 0\n        local l2 = 0\n        local l3 = 0\n\n        for i, len in ipairs(lens) do\n            l3 = l3 + len\n            local buf_a = helper.create_buffer(len)\n            send(device.client.tcp1, buf_a)\n            send(device.server.srva, buf_a)\n        end\n\n        for i = 1, 100 do\n            local buf_a = recv(device.server.srva, nil, 10)\n            local buf_b = recv(device.client.tcp1, nil, 10)\n            l1 = l1 + (buf_a and #buf_a or 0)\n            l2 = l2 + (buf_b and #buf_b or 0)\n            if not buf_a and not buf_b then\n                break\n            end\n        end\n        assert(l1 == l2 and l2 == l3)\n    end,\n\n    tcp_async = function ()\n        ioctl(device.client.tcp3, 'Connect', { to = 'server.srvc'})\n\n        local lens = { 1, 10, 100, 1024, 65507, 65*1024 }\n        local count_1 = 0\n        local count_a = 0\n        local count_3 = 0\n        local count_c = 0\n\n        async.on_recv(device.client.tcp1, nil,\n            function (buf)\n                count_1 = count_1 + #buf\n            end\n        )\n\n        async.on_recv(device.server.srva, nil,\n            function (buf)\n                count_a = count_a + #buf\n            end\n        )\n\n        async.on_recv(device.client.tcp3, nil,\n            function (buf)\n                count_3 = count_3 + #buf\n            end\n        )\n\n        async.on_recv(device.server.srvc, nil,\n            function (buf)\n                count_c = count_c + #buf\n            end\n        )\n\n        local count = 0\n        for i, len in ipairs(lens) do\n            count = count + len\n            local buf_a = helper.create_buffer(len)\n            async.send(device.client.tcp1, buf_a)\n            async.send(device.client.tcp3, buf_a)\n            async.send(device.server.srva, buf_a)\n            async.send(device.server.srvc, buf_a)\n        end\n\n        for i = 1, 1000 do\n            delay(10)\n            if count_a == count and count_c == count and count_1 == count and count_3 == count then\n                break\n            end\n        end\n        async.off_recv(device.client.tcp1)\n        async.off_recv(device.client.tcp3)\n        async.off_recv(device.server.srva)\n        async.off_recv(device.server.srvc)\n\n        -- print(count_1, count_a, count_c, count_3)\n        assert(count_a == count)\n        assert(count_c == count)\n        assert(count_1 == count)\n        assert(count_3 == count)\n        ioctl(device.client.tcp3, 'Disconnect')\n    end,\n\n    tcp_refuse_stop_start = function ()\n        delay(10)\n        ioctl(device.server.srvb, 'Stop')\n        delay(10)\n        ioctl(device.server.srvb, 'Start')\n        delay(10)\n        ioctl(device.client.tcp2, 'Connect', { to = 'server.srvb'})\n        delay(10)\n        ioctl(device.server.srvb, 'Refuse')\n        delay(10)\n        ioctl(device.client.tcp2, 'Disconnect', { to = 'server.srvb'})\n    end\n}\n\n\nfunction entry(vars)\n\n    ioctl(device.client.tcp4, 'Connect')\n\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend\n",
        "params": [
            {
                "id": "t_tcp",
                "title": "t_tcp",
                "vars": null,
                "option": {
                    "topology": "topo_tcp"
                }
            }
        ]
    },
    {
        "id": "rb2b0HDQtb",
        "code": "\nlocal helper = require 'helper'\n\nlocal test = {\n\n    str_err = function ()\n        local err_arr2buff = function (t)\n            return string.arr2buff(t)\n        end\n\n        local err_hex2buff = function (t)\n            return string.hex2buff(t)\n        end\n\n        local err_buff2hex = function (t)\n            return string.buff2hex(t)\n        end\n\n        local res = true\n\n        local bad = { {},  {'a'}, '', {[7] = 99, [9] = 100}, 1, 0, -9.8 }\n        for i, v in ipairs(bad) do\n            res = pcall(err_arr2buff, v)\n            assert(not res)\n            res = pcall(err_hex2buff, v)\n            assert(not res)\n            res = pcall(err_buff2hex, v)\n            assert(not res)\n        end\n\n        res = pcall(err_arr2buff, nil)\n        assert(not res)\n        res = pcall(err_hex2buff, nil)\n        assert(not res)\n        res = pcall(err_buff2hex, nil)\n        assert(not res)\n\n    end,\n\n    str_buf_hex = function ()\n\n        local b1 = string.hex2buff('12 dx')\n        assert(b1 ~= nil)\n        local b2 = string.hex2buff('aa FF 00e 9ab')\n        local b3 = string.hex2buff('aaF F 0 0e9 A B')\n        assert(b2 == b3)\n\n        local s1 = string.buff2hex(' ')\n        assert(s1 ~= nil)\n        local s2 = string.buff2hex(b2)\n        local s3 = string.buff2hex(b3)\n        assert(s2 == s3 and #s2 == #b2*3-1)\n\n        local lens = { 1, 10, 100, 1024, 65*1024 }\n        for idx, value in ipairs(lens) do\n            local s1 = helper.create_bufstr(value)\n            local s2 = string.buff2hex(string.hex2buff(s1))\n            assert(s1 == s2)\n        end\n\n    end,\n\n    str_array = function ()\n        local ok = {}\n        for i = 1, 2050 do\n            table.insert( ok, i, i-1)\n        end\n        local buf1 = string.buff2hex(string.arr2buff(ok))\n        local buf2 = helper.create_bufstr(2050)\n        assert(buf1 == buf2)\n    end\n}\n\n\nfunction entry(vars)\n\n    local filter = \"s\"\n\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend\n",
        "params": [
            {
                "id": "t_string",
                "title": "t_string",
                "vars": null,
                "option": {
                    "topology": "topo_udp"
                }
            }
        ]
    },
    {
        "id": "ZM4PK5rlny",
        "code": "\nlocal helper = require 'helper'\n\nlocal test = {\n\n    serial_send_recv = function()\n        local lens = { 1, 10, 100, 1024, 4555 }\n        local t1 = 0\n        local t2 = 0\n        local t3 = 0\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            local send_len = send(device.dev1.conn1, buf_a)\n            assert(send_len == len)\n            send_len = send(device.dev2.conn1, buf_a)\n            assert(send_len == len)\n\n            t1 = t1 + len\n            local buf_b = recv(device.dev2.conn1, nil, 100)\n            if buf_b then\n                t2 = t2 + #buf_b\n            end\n        end\n        local rbuf = recv(device.dev2.conn1, nil, 100)\n        while rbuf do\n            t2 = t2 + #rbuf\n            rbuf = recv(device.dev2.conn1, nil, 100)\n        end\n        rbuf = recv(device.dev1.conn1, nil, 100)\n        while rbuf do\n            t3 = t3 + #rbuf\n            rbuf = recv(device.dev1.conn1, nil, 100)\n        end\n        assert(t2 == t1 and t2 == t3, t1 .. \" : \" .. t2 .. \" : \" .. t3)\n    end,\n\n    serial_multimsg = function ()\n        local lens = { 1, 10, 100, 1024, 4555 }\n\n        local l1 = 0\n        local l2 = 0\n        local l3 = 0\n        local count = 0\n\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            send(device.dev1.conn1, buf_a)\n            send(device.dev2.conn1, buf_a)\n            l1 = l1 + len\n        end\n\n        local buf_a, buf_b\n        while l2 ~= l1 or l3 ~= l1 do\n            if l2 ~= l1 then\n                buf_a = recv(device.dev1.conn1, nil, 100)\n                l2 = l2 + (buf_a and #buf_a or 0)\n            end\n            if l3 ~= l1 then\n                buf_b = recv(device.dev2.conn1, nil, 100)\n                l3 = l3 + (buf_b and #buf_b or 0)\n            end\n            count = count + 1\n            if count > 1000 then\n                break;\n            end\n        end\n        \n        assert(l1 == l2 and l2 == l3)\n    end,\n\n    -- 异步通信测试\n    serial_async = function()\n        local lens = { 1, 10, 100, 1024, 4555 }\n        local count1 = 0\n        local count2 = 0\n        local count3 = 0\n\n        async.on_recv(device.dev1.conn1, nil,\n            function (buf)\n                -- print('dev1 recved', #buf)\n                count1 = count1 + #buf\n            end\n        )\n\n        async.on_recv(device.dev2.conn1, nil,\n            function (buf)\n                -- print('dev2 recved', #buf)\n                count2 = count2 + #buf\n            end\n        )\n\n        for i, len in ipairs(lens) do\n            local buf_a = helper.create_buffer(len)\n            async.send(device.dev1.conn1, buf_a, nil, function (l) assert(l == len) end)\n            async.send(device.dev2.conn1, buf_a, nil, function (l) assert(l == len) end)\n            count3 = count3 + len\n        end\n\n        -- count2 = #lens\n\n        for i = 1, 2500 do\n            delay(10)\n            if count1 == count3 and count2 == count3 then\n                break\n            end\n        end\n        \n        async.off_recv(device.dev1.conn1)\n        async.off_recv(device.dev2.conn1)\n\n        -- print(count1, count2, count3)\n        assert(count1 == count3 and count2 == count3, count1 .. ':' .. count2 .. ':' .. count3)\n    end,\n\n    serial_ioctl = function ()\n        local com1 = device.dev1.conn1\n        local com2 = device.dev2.conn1\n        local cts, dsr, ri,cd\n        local bool2str = function (b)\n            return b and 'true' or 'false'\n        end\n        local log_state = function (com)\n            cts = ioctl(com, 'GetCTS').result\n            dsr = ioctl(com, 'GetDSR').result\n            ri = ioctl(com, 'GetRI').result\n            cd = ioctl(com, 'GetCD').result\n            if DEBUG then\n                print('cts=' .. bool2str(cts), 'dsr=' .. bool2str(dsr), 'ri=' .. bool2str(ri) , 'cd=' .. bool2str(cd))\n            end\n        end\n        log_state(com1)\n        log_state(com1)\n        ioctl(com1, 'SetRTS', {value = true})\n        ioctl(com1, 'SetDTR', {value = true})\n        log_state(com1)\n        log_state(com2)\n        ioctl(com1, 'SetRTS', {value = false})\n        ioctl(com1, 'SetDTR', {value = false})\n        log_state(com2)\n    end,\n\n    serial_ioctl_break = function()\n        local com1 = device.dev1.conn1\n        local com2 = device.dev2.conn1\n        local buf\n        ioctl(com1, 'SetBreak', {value = true})\n        buf = recv(com2, nil, 200)\n        assert(string.hex2buff('00') == buf)\n        ioctl(com1, 'SetBreak', {value = false})\n        buf = recv(com2, nil, 200)\n        assert(buf == nil)\n    end\n}\n\n\nfunction entry(vars)\n    DEBUG = false\n    local filter = \"s\"\n\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend\n",
        "params": [
            {
                "id": "t_serial",
                "title": "t_serial",
                "vars": null,
                "option": {
                    "topology": "topo_serial"
                }
            }
        ]
    },
    {
        "id": "D_OVZz2CtT",
        "code": "\nlocal helper = require 'helper'\n\nlocal test = {\n\n    timer_timeout = function ()\n        local t1 = now()\n        local _fn_out = nil\n        local count = 0\n        local fn_out = function (aaa, bbb, contiue, ddd)\n            count = count + 1\n            assert(aaa == 1)\n            assert(bbb == 'a')\n            assert(ddd == nil)\n            local t2 = now()\n            assert(t2 - t1 >= 999 and t2 - t1 < 1050, t1 .. '-' .. t2)\n            t1 = now()\n            if contiue then\n                async.timeout(1000, _fn_out, aaa, bbb, false)\n            end\n        end\n        _fn_out = fn_out\n        async.timeout(1000, fn_out, 1, 'a', true)\n        delay(2100)\n        assert(count == 2)\n    end,\n\n    timer_interval = function ()\n        local t1 = now()\n        local count = 1\n        local fn_tick = function (aaa, bbb, ccc)\n            local t2 = now()\n            count  = count + 1\n            assert(aaa == 1)\n            assert(bbb == 'a')\n            assert(ccc == nil)\n            assert(t2 - t1 > 90 and t2 - t1 < 150)\n            t1 = now()\n        end\n        async.interval(100, 100, fn_tick, 1, 'a')\n        delay(1000)\n        assert(count == 10, '' .. count)\n    end\n}\n\n\nfunction entry(vars)\n    DEBUG = false\n    local filter = \"t\"\n\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n    exit()\nend\n",
        "params": [
            {
                "id": "t_timer",
                "title": "t_timer",
                "vars": null,
                "option": {
                    "topology": "topo_udp"
                }
            }
        ]
    },
    {
        "id": "VO-ja7-uUS",
        "code": "\nlocal helper = require 'helper'\n\nlocal test = {\n\n    rt_udp = function ()\n        local len = 0\n        local max_recv_diff = 0\n        local max_send_diff = 0\n        local t1, t2, t3, t4\n        local buff = string.hex2buff('aa bb cc 00 ff ef ff 11 aa bb cc 00 ff ef ff 11 aa bb cc 00 ff ef ff 11')\n\n        async.on_recv(device.udp2_.conn1, nil,\n            function (buf)\n                -- assert(buf == buff)\n                if t3 == nil then\n                    t3 = now('us')\n                else\n                    t4 = now('us')\n                    local diff = (t4 - t3) - len*1000\n                    record.recv_diff = diff\n                    if math.abs(diff) > max_recv_diff then\n                        max_recv_diff = math.abs(diff)\n                    end\n                    record.len = len\n                    t3 = now('us')\n                end\n            end\n        )\n\n        local ticker = function (buff)\n            send(device.udp1_.conn1, buff)\n            if t1 == nil then\n                t1 = now('us')\n            else\n                t2 = now('us')\n                local diff = (t2 - t1) - len*1000\n                record.send_diff = diff\n                if math.abs(diff) > max_send_diff then\n                    max_send_diff = math.abs(diff)\n                end\n                record.len = len\n                t1 = now('us')\n            end\n\n        end\n\n\n        local lens = { 1, 10, 100, 200, 300 }\n        for i, l in ipairs(lens) do\n            len = l\n            t1 = nil\n            t3 = nil\n            local timer = async.interval(l, l, ticker, buff)\n            delay(l * 10)\n            async.clear(timer)\n            delay(400)\n        end\n\n        print('发送调度最大误差 =', max_send_diff .. 'us')\n        print('接收事件最大误差 =', max_recv_diff .. 'us')\n\n    end,\n\n    rt_serial = function ()\n        local b_break = true\n        local count = 0\n        local send = 0\n        local max_diff = 0\n        local t1\n\n        async.on_recv(device.dev2_.conn1, nil,\n            function (buf)\n                count = count + #buf\n            end\n        )\n\n        -- local ticker = function ()\n        --     if t1 == nil then\n        --         t1 = now('us')\n        --     else \n        --         local t2 = now('us')\n        --         local diff = math.abs(t2-t1-1000)\n        --         if diff > max_diff then\n        --             max_diff = diff\n        --         end\n        --         t1 = t2\n        --     end\n        --     ioctl(device.dev1_.conn1, 'SetBreak', {value = b_break})\n        --     if b_break then\n        --         send = send + 1\n        --     end\n        --     b_break = not b_break\n        -- end\n\n        local buf = string.hex2buff('11 22 33 44 55 66 77 88')\n        local ticker = function ()\n            if t1 == nil then\n                t1 = now('us')\n            else \n                local t2 = now('us')\n                local diff = math.abs(t2-t1-1000)\n                if diff > max_diff then\n                    max_diff = diff\n                end\n                t1 = t2\n            end\n            async.send(device.dev1_.conn1, buf)\n            send = send + #buf\n        end\n\n        local timer = async.interval(10, 1, ticker)\n        delay(20000)\n        async.clear(timer)\n        delay(300)\n        print('发送周期 1 ms')\n        print('共发送', send, '字节')\n        print('共接收', count, '字节')\n        print('最大误差 =', max_diff, 'us')\n    end\n}\n\n\nfunction entry(vars)\n\n    local filter = \"r\"\n\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            print('【' .. k .. '】测试开始...')\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend\n",
        "params": [
            {
                "id": "t_rt",
                "title": "t_rt",
                "vars": null,
                "option": {
                    "real_time": true,
                    "rt_cycle": 1000,
                    "rt_policy": "auto",
                    "topology": "topo_rt"
                }
            }
        ]
    },
    {
        "id": "31l5U_YmeC",
        "code": "\nlocal helper = require 'helper'\nlocal test = {\n    test_str_array = function ()\n        local data1 = {}\n        data1.seg_1 = {65535}\n        data1.seg_2 = {\"12rt2\\0\",\"qwer\\0\"}\n        data1.seg_3 = 1.2345\n        local buf = pack(protocol.prot27,data1)\n        local data2 = unpack(protocol.prot27, buf)\n        assert(data1.seg_1[1] == data2.seg_1[1])\n        assert(math.isequal(data1.seg_3,data2.seg_3))\n        assert(data1.seg_2[1] == data2.seg_2[1]..\"\\0\")\n        assert(data1.seg_2[2] == data2.seg_2[2]..\"\\0\")\n    end,\n\n    test_str_array1 = function ()\n        local data1 = {type1=3, type2=1}\n        local buf = pack(protocol.prot28, data1)\n        local data2 = unpack(protocol.prot28, buf)\n        assert(math.isequal(data2.p,-6))\n        assert(math.isequal(data2.type1,data1.type1))\n        assert(math.isequal(data2.type2,data1.type2))\n        assert(math.isequal(data2.x,2))\n        assert(math.isequal(data2.x1,15))\n        assert(math.isequal(data2.p1,-15))\n        assert(data1.p2 == nil)\n    end,\n    test_str_array2 = function ()\n        local data1 = {type1=1, type2=1}\n        local buf = pack(protocol.prot28, data1)\n        local data2 = unpack(protocol.prot28, buf)\n        assert(math.isequal(data2.type1,data1.type1))\n        assert(math.isequal(data2.type2,data1.type2))\n        assert(math.isequal(data2.x11,2))\n        assert(math.isequal(data2.x1,15))\n        assert(math.isequal(7,data2.test))\n    end,\n    test_str_array3 = function ()\n        local data1 ={}\n        data1.seg_3 = 1.002\n        local buf = pack(protocol.prot29, data1)\n        local data2 = unpack(protocol.prot29, buf)\n        assert(math.isequal(data1.seg_3,data2.seg_3))  \n    end,\n\n}\n\nfunction entry(vars)\n\n    local filter = \"t\"\n\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_array_string",
                "title": "t_array_string",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "0V2vTOO7Ql",
        "code": "local helper = require \"helper\"\nlocal test = {\n    test_array = function ()\n        local data1 = {}\n        data1.seg_1 = {34, 45, 98, 345, 1, 0, 234, 12344}\n        data1.seg_2 = {7, -9, 2688}\n        data1.seg_3 = 9999.88889\n        data1.seg_4 = 2\n        local buf = pack(protocol.prot19,data1)\n        local data2 = unpack(protocol.prot19, buf)\n        assert(data1.seg_2[1] == data2.seg_2[1])\n        assert(data1.seg_2[2] == data2.seg_2[2])\n        assert(data1.seg_2[3] == data2.seg_2[3])\n        assert(data1.seg_1[1] == data2.seg_1[1])\n        assert(data1.seg_1[2] == data2.seg_1[2])\n        assert(data1.seg_1[3] == data2.seg_1[3])\n        assert(data1.seg_1[4] == data2.seg_1[4])\n        assert(data1.seg_1[5] == data2.seg_1[5])\n        assert(data1.seg_1[6] == data2.seg_1[6])\n        assert(data1.seg_1[7] == data2.seg_1[7])\n        assert(data1.seg_1[8] == data2.seg_1[8])\n    end,\n    test_array1 = function ()\n        local data1 = {}\n        data1.seg_1 = {34,}\n        data1.seg_2 = {1.2, -1.123}\n        data1.seg_4 = 2.34\n        local buf = pack(protocol.prot20,data1)\n        local data2 = unpack(protocol.prot20, buf)\n        assert(data1.seg_1[1] == data2.seg_1[1])\n        assert(math.isequal(data1.seg_2[1], data2.seg_2[1]))\n        assert(math.isequal(data1.seg_2[2], data2.seg_2[2]))\n        assert(data1.seg_4 == data2.seg_4)\n    end,\n    test_array2 = function ()\n        local data1 = {}\n        data1.seg_1 = {1}\n        data1.seg_2 = {1123, -12133,0}\n        data1.seg_3 = 123\n        data1.seg_4 = {1.222,0,-2.345}\n        local buf = pack(protocol.prot21,data1)\n        local data2 = unpack(protocol.prot21, buf)\n        assert(data1.seg_1[1] == data2.seg_1[1])\n        assert(math.isequal(data1.seg_2[1], data2.seg_2[1]),true)\n        assert(math.isequal(data1.seg_2[2], data2.seg_2[2]),true)\n        assert(math.isequal(data1.seg_4[1], data2.seg_4[1]))\n        assert(math.isequal(data1.seg_4[2], data2.seg_4[2]))\n        assert(math.isequal(data1.seg_4[3], data2.seg_4[3]))\n    end,\n    test_array3 = function ()\n        local data1 = {}\n        data1.seg_1 = {0}\n        data1.seg_2 = {1, -1,0}\n        data1.seg_3 = 123\n        data1.seg_4 = {1.222,0,-2.345}\n        data1.seg_5 = {0}\n        local buf = pack(protocol.prot22,data1)\n        local data2 = unpack(protocol.prot22, buf)\n        assert(data1.seg_1[1] == data2.seg_1[1])\n        assert(math.isequal(data1.seg_2[1], data2.seg_2[1]))\n        assert(math.isequal(data1.seg_2[2], data2.seg_2[2]))\n        assert(math.isequal(data1.seg_4[1], data2.seg_4[1]))\n        assert(math.isequal(data1.seg_4[2], data2.seg_4[2]))\n        assert(math.isequal(data1.seg_4[3], data2.seg_4[3]))\n    end,\n    test_array4 = function ()\n        local msg = message(protocol.prot_array)\n        msg.seg_1 = {0,1}\n        msg.seg_2 = {\"@#$\",\"!!!\"}\n        local data = pack(msg)\n        local data1 = unpack(protocol.prot_array,data)\n        assert(math.isequal(data1.seg_1[1], msg.seg_1[1]))\n        assert(math.isequal(data1.seg_1[2], msg.seg_1[2]))\n        assert(data1.seg_2[1] == msg.seg_2[1])\n        assert(data1.seg_2[2] == msg.seg_2[2])\n    end,\n    test_array5 = function ()\n        local msg = message(protocol.prot_arrays)\n        msg.head = 0\n        msg.array ={number=255,list={seg_1=65535,seg_2=\"65535\"}} \n        local da = pack(msg)\n        local data1 = unpack(protocol.prot_arrays,da)\n        assert(msg.head == data1.head)\n        assert(msg.array.number == data1.array.number)\n        assert(msg.array.list.seg_1 == data1.array.list.seg_1)\n        assert(msg.array.list.seg_2 == data1.array.list.seg_2)\n    end\n\n}\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_array",
                "title": "t_array",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "8Wx3L-gnp1",
        "code": "local helper = require 'helper'\nlocal test = {\n    \n\n    test_ByteSize1 = function ()\n        local msg = {}\n        msg.seg_1 = 0\n        msg.seg_2 = \"$%@#!~\\0\"\n        msg.seg_3 = 0\n        local buf = pack(protocol.prot30,msg)\n        local data = unpack(protocol.prot30, buf)\n        assert(msg.seg_3 == data.seg_1)\n        assert(2 == data.seg_4)\n    end,\n    test_ByteSize2 = function ()\n        local msg = {}\n        msg.seg_1 = 12\n        msg.seg_2 = \"1234%dgjJLLL\\0\"\n        msg.seg_3 = 112\n        local buf = pack(protocol.prot30,msg)\n        local data = unpack(protocol.prot30, buf)\n        assert(2 == data.seg_4)\n    end,\n    test_ByteSize3 = function ()\n        local msg = {}\n        msg.seg_1 = -34\n        msg.seg_2 = \"FFFF\\0\"\n        msg.seg_3 = -987\n        local buf = pack(protocol.prot30,msg)\n        local data = unpack(protocol.prot30, buf)\n        assert(2 == data.seg_4)\n    end,\n    test_ByteSize4 = function ()\n        local msg = {}\n        msg.seg_1 = -34\n        msg.seg_2 = 9223372036854775807\n        msg.seg_3 = -987\n        local buf = pack(protocol.prot31,msg)\n        local data = unpack(protocol.prot31, buf)\n        assert(4 == data.seg_4)\n        assert(4 == data.seg_5)\n        assert(4+4 == data.seg_6)\n        assert(data.seg_4 + data.seg_5 == data.seg_6)\n    end,\n}\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_bytesize",
                "title": "t_bytesize",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "hlbgKS_i9U",
        "code": "local helper = require 'helper'\nlocal test = {\n    test_string = function ()\n        local data1 = {}\n        data1.seg_1 = 4\n        data1.seg_2= \"FSDD\"\n        data1.seg_3= \"的房dfr了ffd\"\n        data1.seg_4 = \"qwe\\0\"\n        data1.seg_5 = '111'\n        local da = pack(protocol.prot16, data1)\n        local data2 = unpack(protocol.prot16, da)\n        assert(data1.seg_1 == data2.seg_1)\n        assert(data1.seg_2 == data2.seg_2)\n        assert(data1.seg_3 == data2.seg_3)\n        assert(data1.seg_4 == data2.seg_4..\"\\0\")\n        assert(data1.seg_5 == data2.seg_5)\n    end,\n    test_string1 = function ()\n        local data1 = {}\n        data1.seg_1 = 4\n        data1.seg_2= \"0.00\"\n        data1.seg_3= \"的房dd\"\n        data1.seg_4 = \"qwe\\0\"\n        data1.seg_5 = '111'\n        local da = pack(protocol.prot16, data1)\n        local data2 = unpack(protocol.prot16, da)\n        assert(data1.seg_1 == data2.seg_1)\n        assert(data1.seg_2 == data2.seg_2)\n        assert(data1.seg_3 == data2.seg_3)\n        assert(data1.seg_4 == data2.seg_4..\"\\0\")\n        assert(data1.seg_5 == data2.seg_5)\n    end,\n    test_string2 = function ()\n        local data1 = {}\n        data1.seg_1 = \"qwer\"\n        data1.seg_2= \"1212\"\n        data1.seg_3= \"erdd\"\n        data1.seg_4 = \"q.we\"\n        local da = pack(protocol.prot17, data1)\n        local data2 = unpack(protocol.prot17, da)\n        assert(data1.seg_1 == data2.seg_1)\n        assert(data1.seg_2 == data2.seg_2)\n        assert(data1.seg_3 == data2.seg_3)\n        assert(data1.seg_4 == data2.seg_4)\n        assert(data1.seg_5 == data2.seg_5)\n    end,\n    test_string3 = function ()\n        local data1 = {seg_1=\"0xaa\\0\"}\n        local da = pack(protocol.prot18, data1)\n        local data2 = unpack(protocol.prot18, da)\n        assert(data2.seg_1== data2.seg_1)\n    end,\n    test_string4 = function ()\n        local msg = message(protocol.string_)\n        msg.test = {str=\"weet\",str1= \"str1\"}\n        local buff = pack(msg)\n        local data = unpack(protocol.string_,buff)\n        assert(msg.test.str == data .test.str )\n    end,\n    test_string5 = function ()\n        local msg = message(protocol.string_, {test={str=\"\\0\",str1='\\3'},te = \"13\"})\n        local buff = pack(msg)\n        local data = unpack(protocol.string_ , buff)\n        assert(msg.test.str == data .test.str )\n        assert(msg.te == data.te )\n    end,\n    test_string6 = function ()\n        local msg = message(protocol.string_)\n        msg.test = {str=\"\\0\",str1='\\3',int=123}\n        msg.te = \"12\"\n        local buff = pack(msg)\n        local data = unpack(protocol.string_ , buff)\n        assert(msg.test.str == data .test.str )\n        assert(msg.te == data.te )\n    end,\n    -- 当定义协议规则为字符串并且以\\0结尾的时候，不给此协议段赋值时，会出现打包失败，该协议段autovalue属性错误\n    -- 定义的协议段为int或者uint时候,autovalue属性不支持数学库计算赋值 举例 autovalue赋值为math.pow(2,5)---得到2的5次方,会显示协议定义错误\n    -- oneof 好像不能在协议组中使用,会报错error get bool value of ==\n    -- oneof的真值表达式不支持math数学库的计算\n    test_string7 = function ()\n        local msg = message(protocol.string_)\n        msg.test = {str='*'}\n        local buff = pack(msg)\n        local data = unpack(protocol.string_, buff)\n        print(data)  \n    end,\n    test_string8 = function ()\n        local msg = message(protocol.string_)\n        \n    end\n}\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n    exit()\nend",
        "params": [
            {
                "id": "t_tstring",
                "title": "t_tstring",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "xTmhcSbozu",
        "code": "local helper = require 'helper'\nlocal test = {\n    test_checkcode = function ()\n        local data = {}\n        data.seg_1 = \"1.3\"\n        local buf = pack(protocol.prot32,data)\n        local data1 = unpack(protocol.prot32,buf)\n        assert(data.seg_1 == data1.seg_1)\n    end,\n    \n    test_checkcode1 = function ()\n        local data = {}\n        data.seg_1 = 34567\n        local buf = pack(protocol.prot33,data)\n        local data1 = unpack(protocol.prot33,buf)\n        assert(data.seg_1 == data1.seg_1)\n    end,\n    \n    test_checkcode2 = function ()\n        local data = {}\n        data.seg_1 = - 34567\n        local buf = pack(protocol.prot34,data)\n        local data1 = unpack(protocol.prot34,buf)\n        assert(data.seg_1 == data1.seg_1)\n    end,\n    test_checkcode3 = function ()\n        local data = {}\n        data.seg_1 = {-22,34}\n        local buf = pack(protocol.prot36,data)\n        local data1 = unpack(protocol.prot36,buf)\n        assert(data.seg_1[1] == data1.seg_1[1])\n    end,\n    \n    \n    test_checkcode4 = function ()\n        local data = {}\n        data.seg_1 = {\"@#\\0\",\"rt\\0\"}\n        local buf = pack(protocol.prot35,data)\n        local data1 = unpack(protocol.prot35,buf)\n        assert(data.seg_1[1] == data1.seg_1[1]..\"\\0\")\n    end,\n    test_checkcode5 = function ()\n        local data = {}\n        data.seg_1 = \"1.3\"\n        local buf = pack(protocol.prot37,data)\n        local data1 = unpack(protocol.prot37,buf)\n        assert(data.seg_1 == data1.seg_1)\n    end,\n    test_checkcode6 = function ()\n        local data = {}\n        data.seg_1 = 34567\n        local buf = pack(protocol.prot38,data)\n        local data1 = unpack(protocol.prot38,buf)\n        assert(data.seg_1 == data1.seg_1)\n    end,\n    test_checkcode7 = function ()\n        local data = {}\n        data.seg_1 = - 34567\n        local buf = pack(protocol.prot39,data)\n        local data1 = unpack(protocol.prot39,buf)\n        assert(data.seg_1 == data1.seg_1)\n    end,\n    test_checkcode8 = function ()\n        local data = {}\n        data.seg_1 = {\"qwe\\0\",\"qwe\\0\"}\n        local buf = pack(protocol.prot40,data)\n        local data1 = unpack(protocol.prot40,buf)\n        assert(data.seg_1[1] == data1.seg_1[1]..\"\\0\")\n    end\n\n}\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_checkcode",
                "title": "t_checkcode",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "wT2NTitc7y",
        "code": "-- 验证补码，反码,大断续，小断续等组合值\n\nlocal helper = require 'helper'\nlocal test ={\n    code_pro1= function ()\n        local data_send = {seg_1=1.23}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_1, data_send.seg_1))\n    end,\n    code_pro2 = function ()\n        local data_send = {seg_2=1.23}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_2, data_send.seg_2,true))\n    end,\n    code_pro3 = function ()\n        local data_send = {seg_3=-111}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_3, data_send.seg_3,true))\n    end,\n    \n    code_pro4 = function ()\n        local data_send = {seg_4=4294967293}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_4, data_send.seg_4,true))\n    end,\n    code_pro5 = function ()\n        local data_send = {seg_4=4294967293,seg_1=1.2,seg_2=1.234,seg_3=234}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_4, data_send.seg_4,true))\n        assert(math.isequal(data_recv.seg_1, data_send.seg_1))\n        assert(math.isequal(data_recv.seg_2, data_send.seg_2,true))\n        assert(math.isequal(data_recv.seg_3, data_send.seg_3,true))\n    end,\n    \n    code_pro6 = function ()\n        local data_send = {seg_5=1.234,seg_6=1.2,seg_7=22345,seg_8=23555774}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_5, data_send.seg_5))\n        assert(math.isequal(data_recv.seg_6, data_send.seg_6))\n        assert(math.isequal(data_recv.seg_7, data_send.seg_7,true))\n        assert(math.isequal(data_recv.seg_8, data_send.seg_8,true))\n    end,\n    code_pro7 = function ()\n        local data_send = {seg_5=-1.234,seg_6=-1.2,seg_7=-22345,seg_8=23555774}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_5, data_send.seg_5))\n        assert(math.isequal(data_recv.seg_6, data_send.seg_6))\n        assert(math.isequal(data_recv.seg_7, data_send.seg_7,true))\n        assert(math.isequal(data_recv.seg_8, data_send.seg_8,true))\n    end,\n    code_pro8 = function ()\n        local data_send = {seg_9=-1.234,seg_10=-1.2,seg_11=-22345,seg_12=4294967293,seg_16=4294967293}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_9, data_send.seg_9))\n        assert(math.isequal(data_recv.seg_10, data_send.seg_10))\n        assert(math.isequal(data_recv.seg_11, data_send.seg_11,true))\n        assert(math.isequal(data_recv.seg_12, data_send.seg_12))\n        assert(math.isequal(data_recv.seg_16, data_send.seg_16))\n    end,\n    code_pro9 = function ()\n        local data_send = {seg_9=1.234,seg_10=1.2,seg_11=22345}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_9, data_send.seg_9))\n        assert(math.isequal(data_recv.seg_10, data_send.seg_10))\n        assert(math.isequal(data_recv.seg_11, data_send.seg_11,true))\n    end,\n    code_pro10 = function ()\n        local data_send = {seg_13=1.234,seg_14=1.2,seg_15=22345}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_13, data_send.seg_13))\n        assert(math.isequal(data_recv.seg_14, data_send.seg_14))\n        assert(math.isequal(data_recv.seg_15, data_send.seg_15,true))\n    end,\n    code_pro11 = function ()\n        local data_send = {seg_13=-1.234,seg_14=-1.2,seg_15=-22345}\n        local buf = pack(protocol.prot_14, data_send)\n        local data_recv = unpack(protocol.prot_14, buf)\n        assert(math.isequal(data_recv.seg_13, data_send.seg_13))\n        assert(math.isequal(data_recv.seg_14, data_send.seg_14))\n        assert(math.isequal(data_recv.seg_15, data_send.seg_15,true))\n    end\n}\nfunction entry(vars)\n    local filter = \"c\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_code",
                "title": "t_code",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "epQNdRZQHvL",
        "code": "-- 验证组合值\nlocal helper = require 'helper'\nlocal test = {\n    com_pro1 = function ()\n        local data_send = {seg_1=1.22}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_1, data_send.seg_1))\n    end,\n    com_pro2 = function ()\n        local data_send = {seg_2=0.23334}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_2, data_send.seg_2,true))\n    end,\n    com_pro3 = function ()\n        local data_send = {seg_3=-111}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_3, data_send.seg_3,true))\n    end,\n    com_pro4 = function ()\n        local data_send = {seg_4=4294967293}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_4, data_send.seg_4))\n    end,\n    com_pro5 = function ()\n        local data_send = {seg_4=4294967293,seg_1=1.2,seg_2=1.234,seg_3=234}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_4, data_send.seg_4,true))\n        assert(math.isequal(data_recv.seg_1, data_send.seg_1))\n        assert(math.isequal(data_recv.seg_2, data_send.seg_2,true))\n        assert(math.isequal(data_recv.seg_3, data_send.seg_3,true))\n    end,\n    com_pro6 = function ()\n        local data_send = {seg_4=4294967293,seg_1=1.2,seg_2=1.234,seg_3=234}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_4, data_send.seg_4,true))\n        assert(math.isequal(data_recv.seg_1, data_send.seg_1))\n        assert(math.isequal(data_recv.seg_2, data_send.seg_2,true))\n        assert(math.isequal(data_recv.seg_3, data_send.seg_3,true))\n    end,\n    com_pro7 = function ()\n        local data_send = {seg_5=1.234,seg_6=1.2,seg_7=22345,seg_8=23555774}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_5, data_send.seg_5))\n        assert(math.isequal(data_recv.seg_6, data_send.seg_6))\n        assert(math.isequal(data_recv.seg_7, data_send.seg_7,true))\n        assert(math.isequal(data_recv.seg_8, data_send.seg_8,true))\n    end,\n    com_pro8 = function ()\n        local data_send = {seg_9=-1.234,seg_10=-1.2,seg_11=-22345,seg_12=23555774}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_9, data_send.seg_9))\n        assert(math.isequal(data_recv.seg_10, data_send.seg_10))\n        assert(math.isequal(data_recv.seg_11, data_send.seg_11,true))\n        assert(math.isequal(data_recv.seg_12, data_send.seg_12,true))\n    end,\n    com_pro9 = function ()\n        local data_send = {seg_9=1.234,seg_10=1.2,seg_11=22345,seg_12=235557}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_9, data_send.seg_9))\n        assert(math.isequal(data_recv.seg_10, data_send.seg_10))\n        assert(math.isequal(data_recv.seg_11, data_send.seg_11,true))\n        assert(math.isequal(data_recv.seg_12, data_send.seg_12,true))\n    end,\n    com_pro10 = function ()\n        local data_send = {seg_13=0.6789,seg_14=2.4567,seg_15=-2233345,seg_16=777685}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_13, data_send.seg_13))\n        assert(math.isequal(data_recv.seg_14, data_send.seg_14))\n        assert(math.isequal(data_recv.seg_15, data_send.seg_15,true))\n        assert(math.isequal(data_recv.seg_16, data_send.seg_16,true))\n    end,\n    com_pro11 = function ()\n        local data_send = {seg_13=-0.6789,seg_14=-2.4567,seg_15=-233345,seg_16=777685}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_13, data_send.seg_13))\n        assert(math.isequal(data_recv.seg_14, data_send.seg_14))\n        assert(math.isequal(data_recv.seg_15, data_send.seg_15,true))\n        assert(math.isequal(data_recv.seg_16, data_send.seg_16,true))\n    end,\n    com_pro12 = function ()\n        local data_send = {seg_17=424,seg_18=43547,seg_19=127,seg_20=126}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_17, data_send.seg_17))\n        assert(math.isequal(data_recv.seg_18, data_send.seg_18))\n        assert(math.isequal(data_recv.seg_19, data_send.seg_19,true))\n        assert(math.isequal(data_recv.seg_20, data_send.seg_20,true))\n    end,\n    com_pro13 = function ()\n        local data_send = {seg_17=-424,seg_18=43547,seg_19=-127,seg_20=126}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_17, data_send.seg_17))\n        assert(math.isequal(data_recv.seg_18, data_send.seg_18))\n        assert(math.isequal(data_recv.seg_19, data_send.seg_19,true))\n        assert(math.isequal(data_recv.seg_20, data_send.seg_20,true))\n    end,\n    com_pro14 = function ()\n        local data_send = {seg_13=0,seg_15=0}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_13, data_send.seg_13))\n        assert(math.isequal(data_recv.seg_15, data_send.seg_15))\n        assert(math.isequal(data_recv.seg_15, data_send.seg_15,true))\n    end,\n    com_pro15 = function ()\n        local data_send = {seg_17=0,seg_18=0,seg_19=0,seg_20=0}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_17, data_send.seg_17))\n        assert(math.isequal(data_recv.seg_18, data_send.seg_18))\n        assert(math.isequal(data_recv.seg_19, data_send.seg_19,true))\n        assert(math.isequal(data_recv.seg_20, data_send.seg_20,true))\n    end,\n    com_pro16 = function ()\n        local data_send = {seg_1=-1.234,seg_17=-0.0,seg_15=-22345}\n        local buf = pack(protocol.prot_15, data_send)\n        local data_recv = unpack(protocol.prot_15, buf)\n        assert(math.isequal(data_recv.seg_1, data_send.seg_1))\n        assert(math.isequal(data_recv.seg_17, data_send.seg_17))\n        assert(math.isequal(data_recv.seg_15, data_send.seg_15,true))\n    end\n}\n\n\nfunction entry(vars)\n    local filter = \"c\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_com",
                "title": "t_com",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "2QN09z0t7_R",
        "code": "-- 验证double中间值\nlocal helper = require 'helper'\nlocal test = {\n    double_T_pro = function ()\n        local data_send = {seg_2=0,}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_2== data_send.seg_2)\n    end,\n    -- 验证double最小边界值\n    double_Bmax_pro = function ()\n        local data_send = {seg_2=-1.7976E+308}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_2== data_send.seg_2)\n    end,\n    -- 验证double最大边界值\n    double_Bmin_pro = function ()\n        local data_send = {seg_2=1.7976E+308}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_2== data_send.seg_2)\n    end,\n    -- 验证double随机值\n    double_S_pro = function ()\n        local data_send = {seg_2=1.797667}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_2== data_send.seg_2)\n    end,\n    -- 验证double随机值\n    double_int_pro = function ()\n        local data_send = {seg_2=0}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_2== data_send.seg_2)\n    end,\n    -- 验证double随机值\n    double_ints_pro = function ()\n        local data_send = {seg_2=1}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_2== data_send.seg_2)\n    end,\n\n\n}\nfunction entry(vars)\n    local filter = \"d\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_double",
                "title": "t_double",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "MEMmUkpfjVp",
        "code": "local helper = require 'helper'\nlocal test = {\n    -- 验证float中间值\n    float_T_pro = function ()\n        local data_send = {seg_1=0}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_1== data_send.seg_1)\n    end,\n\n    -- 验证float最小边界值\n    float_Bmin_pro = function ()\n        local data_send = {seg_1=-3.3999999521443642e+38,}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_1== data_send.seg_1)\n    end,\n        -- 验证float最大边界值\n    float_Bmax_pro =  function ()\n        local data_send = {seg_1=3.3999999521443642e+38,}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_1== data_send.seg_1)\n    end,\n    -- 验证float随机值 小数位需要为15位\n    float_S_pro =function ()\n        local data_send = {seg_1=3.399519920349121}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_1== data_send.seg_1)  \n    end,\n    float_s_pro =function ()\n        local data_send = {seg_1=1}\n        local buf = pack(protocol.prot_13, data_send)\n        local data_recv = unpack(protocol.prot_13, buf)\n        assert(data_recv.seg_1== data_send.seg_1)  \n    end,\n}\n\nfunction entry(vars)\n    local filter = \"f\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_float",
                "title": "t_float",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "vp1B1p0n9Vc",
        "code": "local helper = require 'helper'\nlocal test = {\n    -- 验证int8的整倍数\n    int_Pro = function ()\n        local data_send = {seg_8=127,seg_16=6533,seg_24=167215,seg_32=-42949293}\n        local buf = pack(protocol.prot_11, data_send)\n        local data_recv = unpack(protocol.prot_11, buf)\n        assert\n            (\n                data_recv.seg_8 == data_send.seg_8 \n            and data_recv.seg_16 == data_send.seg_16 \n            and data_recv.seg_24 == data_send.seg_24  \n            and data_recv.seg_32 == data_send.seg_32\n            ) \n    end,\n    -- 验证int特殊组合\n\n    iEight_pro = function ()\n        local data_send = {seg_1=1,seg_31=-64525591,seg_2=1,seg_30=-16177055}\n        local buf = pack(protocol.prot_11, data_send)\n        local data_recv = unpack(protocol.prot_11, buf)\n\n        assert\n            (\n                data_recv.seg_1 == 1 \n            and data_recv.seg_2 == data_send.seg_2 \n            and data_recv.seg_30 == data_send.seg_30 \n            and data_recv.seg_31 == data_send.seg_31 \n            ) \n\n    end,\n    -- 验证int随意位数组合\n    iSun_pro = function ()\n        local data_send = {seg_15=3268,seg_17=13172,seg_14=-1383,seg_18=2614}\n        local buf = pack(protocol.prot_11, data_send)\n        local data_recv = unpack(protocol.prot_11, buf)\n\n        assert(\n            data_recv.seg_14 == data_send.seg_14 \n        and data_recv.seg_15 == data_send.seg_15 \n        and data_recv.seg_17 == data_send.seg_17 \n        and data_recv.seg_18 == data_send.seg_18\n        ) \n    end,\n}\n\nfunction entry(vars)\n    local filter = \"i\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_int",
                "title": "t_int",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "7MqRFANoXkP",
        "code": "local helper = require 'helper'\nlocal test = {\n    test_oneof1 =function ()\n        local data1 = {type1=2, type2=1}\n        local buf = pack(protocol.prot23, data1)\n        local data2 = unpack(protocol.prot23, buf)\n        assert(data2.z==nil)\n        assert(math.isequal(data1.type1, data2.type1))\n        assert(math.isequal(data1.type2, data2.type2))\n    end,\n    \n    \n    test_oneof2 = function ()\n        local data1 = {type1=0, type2=1,  x1=1.11}\n        -- local data1 = {type1=0, type2=1}\n        local buf = pack(protocol.prot23, data1,true)\n        local data2 = unpack(protocol.prot23, buf)\n        assert(data2.y==nil)\n        assert(data2.z==nil)\n        assert(math.isequal(data1.type2, data2.type2))\n        -- assert(math.isequal(n, data2.x))\n        assert(math.isequal(1.11, data2.x1))\n    end,\n    test_oneof3 = function ()\n        local data1 = {type1=2, type2=1}\n        local buf = pack(protocol.prot24, data1)\n        local data2 = unpack(protocol.prot24, buf)\n        assert(math.isequal(data2.p,1.6))\n        assert(math.isequal(data2.type1,data1.type1))\n        assert(math.isequal(data2.type2,data1.type2))\n        assert(math.isequal(data2.x,3))\n        assert(math.isequal(data2.x1,2.23))\n        assert(math.isequal(data2.p,1.6))\n    end,\n    test_oneof4 = function ()\n        local data1 = {type1=3, type2=1}\n        local buf = pack(protocol.prot25, data1)\n        local data2 = unpack(protocol.prot25, buf)\n        assert(math.isequal(data2.p,-6))\n        assert(math.isequal(data2.type1,data1.type1))\n        assert(math.isequal(data2.type2,data1.type2))\n        assert(math.isequal(data2.x,2))\n        assert(math.isequal(data2.x1,15))\n        assert(math.isequal(data2.p1,-15))\n    end,\n    test_oneof5 = function ()\n        local data1 = {type1=3, type2=1}\n        local buf = pack(protocol.prot26, data1)\n        local data2 = unpack(protocol.prot26, buf)\n        assert(math.isequal(data2.p,-6))\n        assert(math.isequal(data2.type1,data1.type1))\n        assert(math.isequal(data2.type2,data1.type2))\n        assert(math.isequal(data2.x,2))\n        assert(math.isequal(data2.x1,15))\n        assert(math.isequal(data2.p1,-15))\n        assert(data1.p2 == nil)\n        assert(data2.p2 == \"qwe\")\n    end,\n    test_oneof_segments = function ()\n        -- local msg = {xx = 2,oneof_name = {str = \"qqq\",seg_name =1.11,list={12,11},test={qq=5,qs={ww=24,ee=(math.pow(2,40)-1),tt={\"ew\",\"er\"}}}}}\n        local msg = {xx=2,aa=6}\n        local data = pack(protocol.oneof_prot, msg)\n        local data2 = unpack(protocol.oneof_prot, data)\n        assert(data2.oneof_name.test.qs.string == \"123\")\n        \n    end,\n    test_oneofs = function ()\n        local msg = {str=\"123\"}\n        local buff = pack(protocol.one_prot,msg)\n        local data = unpack(protocol.one_prot,buff)\n        assert(msg.str == data.str)\n        assert(data.name == 0)\n        assert(data.float == 0)\n    end\n}\n\n\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_oneof",
                "title": "t_oneof",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "Z9joSyPPOhY",
        "code": "local helper = require 'helper'\nlocal test = {\n    test_recv = function ()\n        send(device.dev12.s2, \"msf\\0\",{to=\"dev12.s1\"})\n        delay(1000)\n        local s1, s2 = recv(device.dev12.s1, nil);\n    end,\n    test_recv1 = function ()\n        local msg = message(protocol.prot_arrays)\n        msg.head = 1\n        send(device.dev12.s2, msg,{to=\"dev12.s1\"})\n        delay(100)\n        local s1, s2 = recv(device.dev12.s1, nil)\n        local data = unpack(protocol.prot_arrays,s1)\n        assert(data.array.list.seg_1 == 1)\n        assert(data.array.list.seg_1 == 1)\n        assert(data.array.number == 1)\n        assert(data.head == msg.head)\n    end,\n    test_recv2 = function ()\n        local msg = \"msfasdfasdfsadfdddddddddddddddddddddddddddddddddddddsdgdffffgsertweytyu \\\n        ddddddfgsdfddrfw3qrwerfiopsadufsrsd1f354d5s21f2ds1fq43w4rew54rr5asd45asfd f asdf\"\n        send(device.dev12.s2, msg,{to=\"dev12.s1\"})\n        delay(100)\n        local s1, s2 = recv(device.dev12.s1, nil)\n        assert(s1==msg)\n    end,\n}\n\n\n\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_recv",
                "title": "t_recv",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "mKTK-Pfv_L7",
        "code": "\nlocal helper = require 'helper'\nlocal test = {\n    test_send = function ()\n        local msg = message(protocol.send_1)\n        msg.seg1 = 4\n        msg.seg2 = {0,2,3, 4}\n    \n        local sta = \"qwerrrrewqrfasfasdfdftjhuiangiweas;ddfl;ksafffowqpa'wojtsafsdfsdfsdffasdfasadffatteryfggdjgdfjferrrrewqrfasfasdfdftjhuiangiweas;ddfl;ksafffowqpa'wojtsafsdfsdfsdffasdfasadffatteryfggdjgdfjfhrewyysdfijerrrrewqrfasfasdfdftjhuiangiweas;ddfl;ksafffowqpa'wojtsafsdfsdfsdffasdfasadffatteryfggdjgdfjfhrewyysdfijerrrrewqrfasfasdfdftjhuiangiweas;ddfl;ksafffowqpa'wojtsafsdfsdfsdffasdfasadffatteryfggdjgdfjfhrewyysdfijhrewyysdfijsdljgjgsdklfjoweapruiweerpawesdffsafdsafasoiperwafsdlkff;lskfa;sdkfals;akfoweairpoqwererrrwwwwwwaarsdzffffaaaaaasdffgdsffgdaaffsdfearrerrrtgadtsgdfsdgsdfgdsfsgdgsdfgheaytgwajfksdjfa;ssfjoweiporujsaafjksdjflsafisdoafihwawejopqqruosajfaklsdjfgisahgiosdetjgfsd1112223\"\n        send(device.dev12.udp_name, msg)\n        send(device.dev12.udp_name, \"msg\")\n        send(device.dev12.udp_name, \"msg\\0\")\n        send(device.dev12.udp_name, \"\")\n        send(device.dev12.udp_name, sta)\n        send(device.dev12.s1, \"msg\\0\",{to_port=8000})\n        -- 总线连接中通过设置`to`属性标识目标设备接口\n        send(device.dev12.s3,msg,{to='dev11.c2'})\n     \n        -- send(device.dev12.s1, msg)\n        -- send(device.dev12.s3, msg)\n        -- send(device.dev12.s4, msg, {to_port=8000})\n        -- send(device.dev12.udp_name, string.buf('AA 55 E2 B3'))\n        -- send(device.dev2.uu2, msg)\n \n    end\n    \n}\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_send",
                "title": "t_send",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "GjtcArxzUc8",
        "code": "local helper = require 'helper'\nlocal test = {\n    -- 验证uint的8的整数倍数\n    uint_pro = function ()\n        local data_send = {seg_8=127,seg_16=65535,seg_24=16777213,seg_32=4294967293}\n        local buf = pack(protocol.prot_12, data_send)\n        local data_recv = unpack(protocol.prot_12, buf)\n\n        assert\n            (\n                data_recv.seg_8 == data_send.seg_8 \n            and data_recv.seg_16 == data_send.seg_16 \n            and data_recv.seg_24 == data_send.seg_24  \n            and data_recv.seg_32 == data_send.seg_32\n            ) \n    end,\n    -- 验证unit特殊值\n    unit_T_pro = function ()\n\n        local data_send = {seg_1=0,seg_31=2147483639,seg_2=1,seg_30=1073741823}\n        local buf = pack(protocol.prot_12, data_send)\n        local data_recv = unpack(protocol.prot_12, buf)\n\n        assert\n            (\n                data_recv.seg_1 == 0 \n            and data_recv.seg_2 == data_send.seg_2 \n            and data_recv.seg_30 == data_send.seg_30 \n            and data_recv.seg_31 == data_send.seg_31 \n            ) \n    end,\n\n    -- 验证uint随机值\n    unit_S_pro = function ()\n        local data_send = {seg_15=32761,seg_17=131071,seg_14=16383,seg_18=26143}\n        local buf = pack(protocol.prot_12, data_send)\n        local data_recv = unpack(protocol.prot_12, buf)\n        assert(\n            data_recv.seg_14 == data_send.seg_14 \n        and data_recv.seg_15 == data_send.seg_15 \n        and data_recv.seg_17 == data_send.seg_17 \n        and data_recv.seg_18 == data_send.seg_18\n        ) \n    end,\n\n\n-- 验证uint随机值\n    unit_S_pro_int = function ()\n        local data_send = {seg_15=0,seg_17=1,seg_14=1,seg_18=0}\n        local buf = pack(protocol.prot_12, data_send)\n        local data_recv = unpack(protocol.prot_12, buf)\n        assert(\n            data_recv.seg_14 == data_send.seg_14 \n        and data_recv.seg_15 == data_send.seg_15 \n        and data_recv.seg_17 == data_send.seg_17 \n        and data_recv.seg_18 == data_send.seg_18\n        ) \n    end\n}\nfunction entry(vars)\n    local filter = \"u\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_uint",
                "title": "t_uint",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "2WeJu_cXYwr",
        "code": "local helper = require 'helper'\nlocal test = {\n    test_message = function ()\n        local msg = message(protocol.prot_message)\n        msg.seg_message = 255\n        msg.seg_messages = {msg_string = \"wer\", msg = {\"---\", \"///\"}, uint = 18446744073709551615}\n        local buf = pack(msg)\n        local msg1 = unpack(protocol.prot_message, buf)\n        verify(msg1.seg_message == msg.seg_message,\"断言失败\")\n        verify(msg.seg_messages.uint == 18446744073709551615, \"断言失败\")\n        \n    end,\n    test_message1 = function ()\n        local msg = message(protocol.prot_message,{seg_message = 0,seg_messages={msg_string = \"$#@\", msg = {\"-*-\", \"0o=\"}, uint =0xffffffffffffffff}})\n        local buf = pack(msg)\n        local msg1 = unpack(protocol.prot_message, buf)\n        verify(msg1.seg_message == msg.seg_message,\"断言失败\")\n        verify(msg.seg_messages.uint == msg1.seg_messages.uint, \"断言失败\")\n        assert(msg.seg_messages.msg[1] == msg1.seg_messages.msg[1])\n       \n    end,\n    test_now = function ()\n        local t1 = now()\n        delay(10)\n        local t2 = now()\n        print(\"ms\",t2-t1)\n    end,\n    test_now1 = function ()\n        local t1 = now('us')\n        delay(10)\n        local t2 = now(\"us\")\n        print(\"us\",t2-t1)\n    \n    end,\n    test_now2 = function ()\n        local t1 = now('ns')\n        delay(10)\n        local t2 = now(\"ns\")\n        print(\"ns\",t2-t1)\n        \n    end\n}\n\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_message_now",
                "title": "t_message_now",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "U3jsnSM7w6Q",
        "code": "local helper = require 'helper'\nlocal test = {\n    t_user_ok = function ()\n        --提示用户进行确认\n        local answer1 = ask('ok',  {title='提示', msg='确认后继续'})\n        print(answer1) ------>'ok'\n    end,\n    t_user_yesno = function ()\n         --提示用户选择是与否,默认为true\n        local answer2 = ask('yesno',  {title='提示', msg='请回答yes或no', default=true})\n        print(answer2)------>true|false\n    end,\n    t_user_input_string = function ()\n        --提示用户输入字符串,默认是abcd\n        local answer3 = ask('text', {title='提示', msg='输入字符串', default='abcd'})\n        print(answer3)-------->'abcd'\n    end,\n    t_user_input_number = function ()\n        --提示用户输入数字,默认是3，\n        local answer4 = ask('number', {title='提示', msg='输入数字', default=3})\n        print(answer4)-------->3\n    end,\n    t_user_check = function ()\n        --提示用户选择某一项,默认第一项\n        local answer4 = ask('select', {title='提示', msg='请选择', default='第一项', items={'第一项','第二项', '第三项'} })\n        print(answer4)------------> '第一项'\n        \n    end,\n    t_user_state = function ()\n        -- 提示用户按如下指示进行操作，on是默认状态，disabled是否可以编辑\n        local answer5 = ask(\"multiswitch\", \n                {\n                    title = \"提示\", \n                    msg = \"按照以下指示进行开关操作\", \n                    items = {\n                        {\n                            name = \"xxx开关名称1\",\n                            value = \"x2-34\",\n                            on = true,\n                            disabled = true,\n                        }, {\n                            name = \"xxx开关名称2\",\n                            value = \"x2-35\",\n                            on = false,\n                            disabled = false,\n                        }\n                    }\n                }\n            )\n        print(answer5)------------> ['x2-34']\n    end\n\n}\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n    exit()\nend",
        "params": [
            {
                "id": "t_ask",
                "title": "t_ask",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "n5_MSvxhnTl",
        "code": "local helper = require 'helper'\nlocal test = {\n    -- 记录普通日志信息输出结果为绿色\n    test_info = function ()\n        local msg = \"记录普通日志信息输出结果为绿色\"\n        log.info(msg)\n    end,\n    -- 记录警告日志信息输出结果为黄色\n    test_warn = function ()\n        local msg = '记录警告日志信息输出结果为黄色'\n        log.warn(msg)\n    end,\n    -- 记录错误的日志信息输出结果为红色\n    test_error = function ()\n        local msg = \"记录错误的日志信息输出结果为红色\"\n        log.error(msg)\n    end,\n    -- 记录测试步骤信息\n    test_step = function ()\n        local msg = \"测试步骤\"\n        log.step(msg)\n    end,\n    -- 记录测试动作执行记录\n    test_action = function ()\n        local msg = \"记录测试动作执行记录\"\n        log.action(msg)\n    end,\n    -- 输出正在执行的测试信息\n    test_doing = function ()\n        local msg = \"输出正在执行的测试信息\"\n        log.action(msg)\n    end,\n    -- 输出检查结果的日志，第一个参数是字符串，第二个为布尔值\n    test_check = function ()\n        local msg = '检查结果日志'\n        log.check(msg,true)\n        \n    end\n}\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n    exit()\nend",
        "params": [
            {
                "id": "t_log",
                "title": "t_log",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    },
    {
        "id": "DxH33lNB6H-",
        "code": "local helper = require 'helper'\nlocal test = {\n    -- 处理超时定时器\n    \n    timer1 = function ()\n        local list = {}\n        local timer_id = nil\n        for i = 1, 500 do\n            local mod = math.fmod(i, 2)\n            if mod > 0 then\n                local test_out = function (data)\n                end\n                timer_id = async.timeout(1000,test_out)\n                table.insert(list, timer_id)\n            end\n        end\n        for i in pairs(list) do\n           async.clear(i)\n        end \n    end,\n}\n\nfunction entry(vars)\n    local filter = \"t\"\n    for k, t in pairs(test) do\n        if string.sub(k, 1, 1) == filter then\n            local t1 = now()\n            local ok, res = pcall(t, vars)\n            local t2 = now()\n            if ok then\n                log.info('【' .. k .. '】测试通过(' .. (t2-t1) .. 'ms)')\n            else\n                record.test_case = k\n                record.test_result = res\n                log.error('【' .. k .. '】测试失败, ' .. helper.trim_error_info(res))\n            end\n        end\n    end\n\n    exit()\nend",
        "params": [
            {
                "id": "t_time",
                "title": "t_time",
                "vars": null,
                "option": {
                    "topology": "topo11"
                }
            }
        ]
    }
]