{
    "pack": "\r\n-- -- 打包函数\r\n-- -- 协议段打包时调用\r\n-- -- 输入参数 seg_name: 协议段名称、seg_value：协议段值、 prot_data：全部协议数据\r\n-- -- 返回值：返回打包后的字符串\r\n\r\n\r\n-- --将浮点数打包成字符串 字符D替换小数点\r\n-- function packFloat_D(seg_name, seg_value, prot_data)\r\n--     local str = string.format(\"%.5f\", seg_value)\r\n--     if seg_name=='WD' then  --纬度是最后一个字符串，不需要分割符F\r\n--         return string.gsub(str, \"%.\", \"D\")\r\n--     else \r\n--         return string.gsub(str, \"%.\", \"D\")..'F'\r\n--     end\r\n-- end\r\n\r\n\r\n-- --将浮点数放大10倍后打包成整数字符串\r\n-- function packFloat_I(seg_name, seg_value, prot_data)\r\n--     return string.format(\"%.0f\", seg_value*10)..'F'\r\n-- end\r\n\r\n-- -- 函数体外面可以编写即时执行的测试代码\r\n-- -- 正式使用之前，请注释之\r\n\r\n-- local result1 = packFloat_D(\"segx\", 98657.55208009)\r\n-- print('数字\"98657.55208009\"，使用 packFloat_D (\"segx\", ) 打包后的结果是字符串：', result1)\r\n\r\n-- result1 = packFloat_D(\"WD\", 98657.55208009)\r\n-- print('数字\"98657.55208009\"，使用 packFloat_D (\"WD\", ) 打包后的结果是字符串：', result1)\r\n\r\n-- local result2 = packFloat_I(\"sega\", 98657.55208009)\r\n-- print('数字“98657.55208009”，使用 packFloat_I (, ) 打包后的结果是字符串：', result2)",
    "unpack": "\r\n-- -- 解包函数\r\n-- -- 协议段解包时调用\r\n-- -- 输入参数 seg_name: 协议段名称、prot_buff：协议包原始字节、 pos: 当前解析位置、prot_data：已解析得到的数据\r\n-- -- 返回值：必须返回2个值，第1个为解析得到的值，第2个为解析使用的字节长度\r\n\r\n\r\n-- --将含D字符的string解包成浮点数\r\n-- function unpackFloat_D(seg_name, prot_buff, pos, prot_data)\r\n--     local pos_end = pos\r\n--     local str = ''\r\n\r\n--     if seg_name=='WD' then\r\n--         pos_end = string.len(prot_buff)\r\n--         str = string.sub(prot_buff, pos, pos_end)\r\n--     else \r\n--         pos_end = string.find(prot_buff, 'F', pos)\r\n--         str = string.sub(prot_buff, pos, pos_end-1)\r\n--     end\r\n--     str = string.gsub(str, 'D', '.')\r\n--     return tonumber(str), pos_end-pos+1\r\n-- end\r\n\r\n\r\n-- --将整数字符串解包成缩小10倍的浮点数\r\n-- function unpackFloat_I(seg_name, prot_buff, pos, prot_data)\r\n--     local pos_end = string.find(prot_buff, 'F', pos)\r\n--     local str = string.sub(prot_buff, pos, pos_end-1)\r\n--     return tonumber(str)/10, pos_end-pos+1\r\n-- end\r\n\r\n-- -- 函数体外面可以编写即时执行的测试代码\r\n-- -- 正式使用之前，请注释之\r\n-- local result1 = unpackFloat_D(\"WD\", \"12D3489\", 1, nil)\r\n-- print('字符串\"12D3489\"，使用 unpackFloat_D (\"WD\", ) 解包后的结果为数字: ', result1)\r\n\r\n-- result1 = unpackFloat_D(\"segxx\", \"12D3489F\", 1, nil)\r\n-- print('字符串\"12D3489F\"，使用 unpackFloat_D (\"segxx\", ) 解包后的结果为数字: ', result1)\r\n\r\n-- local result2 = unpackFloat_I(\"segb\", \"12356F\", 1, nil)\r\n-- print('字符串\"12356F\"，使用 unpackFloat_I ( ) 解包后的结果为数字: ', result2)\r\n",
    "crc": "\r\n-- -- 校验函数\r\n-- -- 校验函数用于生成原始字节的校验码\r\n-- -- 输入参数 prot_buff: 协议包原始字节、pos_begin：校验开始字节位置、pos_end：校验结束字节位置\r\n-- -- 返回值：返回特定长度字符串\r\n\r\n-- -- xor8校验后转字符串\r\n-- function my_xor8(prot_buff, pos_begin, pos_end)\r\n--     local res = 0\r\n--     for i=pos_begin, pos_end do\r\n--         res = res ~ string.byte(prot_buff, i)\r\n--     end\r\n--     return string.format(\"%02X\", res)\r\n-- end\r\n\r\n-- -- 函数体外面可以编写即时执行的测试代码\r\n-- -- 正式使用之前，请注释之\r\n-- local test_str = \"aabbccff\"\r\n-- local result = my_xor8(test_str, 1, #test_str)\r\n-- print('\"', test_str, '\" 使用my_xor8 ( ) 得到的校验结果为： ', result)\r\n\r\n-- test_str = \"aabbefg\"\r\n-- result = my_xor8(test_str, 1, #test_str)\r\n-- print('\"', test_str, '\" 使用my_xor8 ( ) 得到的校验结果为： ', result)\r\n\r\n"
}